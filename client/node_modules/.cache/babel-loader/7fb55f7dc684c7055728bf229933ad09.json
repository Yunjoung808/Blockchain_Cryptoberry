{"ast":null,"code":"/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-providers-ws/src/index.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n\n/** @file WebsocketProvider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar errors = require('../../../caver-core-helpers').errors;\n\nvar Ws = null;\nvar _btoa = null;\nvar parseURL = null;\n/* eslint-disable no-undef */\n\nif (typeof window !== 'undefined' && typeof window.WebSocket !== 'undefined') {\n  Ws = window.WebSocket;\n  _btoa = btoa;\n\n  parseURL = function parseURL(url) {\n    return new URL(url);\n  };\n} else {\n  Ws = require('websocket').w3cwebsocket;\n\n  _btoa = function _btoa(str) {\n    return Buffer.from(str).toString('base64');\n  };\n\n  var url = require('url');\n\n  if (url.URL) {\n    // Use the new Node 6+ API for parsing URLs that supports username/password\n    var newURL = url.URL;\n\n    parseURL = function parseURL(u) {\n      return new newURL(u);\n    };\n  } else {\n    parseURL = require('url').parse;\n  }\n} // Default connection ws://localhost:8546\n\n\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n  var _this = this;\n\n  this.responseCallbacks = {};\n  this.notificationCallbacks = [];\n  options = options || {};\n  this._customTimeout = options.timeout; // The w3cwebsocket implementation does not support Basic Auth\n  // username/password in the URL. So generate the basic auth header, and\n  // pass through with any additional headers supplied in constructor\n\n  var parsedURL = parseURL(url);\n  var headers = options.headers || {};\n  var protocol = options.protocol || undefined;\n\n  if (parsedURL.username && parsedURL.password) {\n    headers.authorization = \"Basic \".concat(_btoa(\"\".concat(parsedURL.username, \":\").concat(parsedURL.password)));\n  } // Allow a custom client configuration\n\n\n  var clientConfig = options.clientConfig || undefined;\n  this.connection = new Ws(url, protocol, undefined, headers, undefined, clientConfig);\n\n  this.reconnect = () => new Ws(url, protocol, undefined, headers, undefined, clientConfig);\n\n  this.addDefaultEvents(); // LISTEN FOR CONNECTION RESPONSES\n\n  this.connection.onmessage = function (e) {\n    var data = typeof e.data === 'string' ? e.data : '';\n\n    _this._parseResponse(data).forEach(function (result) {\n      var id = null; // get the id which matches the returned id\n\n      if (_.isArray(result)) {\n        result.forEach(function (load) {\n          if (_this.responseCallbacks[load.id]) {\n            id = load.id;\n          }\n        });\n      } else {\n        id = result.id;\n      } // notification\n\n\n      if (!id && result.method.indexOf('_subscription') !== -1) {\n        _this.notificationCallbacks.forEach(function (callback) {\n          if (_.isFunction(callback)) {\n            callback(result);\n          }\n        }); // fire the callback\n\n      } else if (_this.responseCallbacks[id]) {\n        _this.responseCallbacks[id](null, result);\n\n        delete _this.responseCallbacks[id];\n      }\n    });\n  };\n};\n/**\n Will add the error and end event to timeout existing calls\n\n @method addDefaultEvents\n */\n\n\nWebsocketProvider.prototype.addDefaultEvents = function () {\n  var _this = this;\n\n  this.connection.onerror = function () {\n    _this._timeout();\n  };\n\n  this.connection.onclose = function () {\n    _this._timeout(); // reset all requests and callbacks\n\n\n    _this.reset();\n  }; // this.connection.on('timeout', function(){\n  //     _this._timeout();\n  // });\n\n};\n/**\n Will parse the response and make an array out of it.\n\n @method _parseResponse\n @param {String} response\n */\n\n\nWebsocketProvider.prototype._parseResponse = function (response) {\n  var _this = this;\n\n  var returnValues = []; // DE-CHUNKER\n\n  var dechunkedData = response.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n  .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n  .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n  .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n  .split('|--|');\n  dechunkedData.forEach(function (data) {\n    // prepend the last chunk\n    if (_this.lastChunk) {\n      data = _this.lastChunk + data;\n    }\n\n    var result = null;\n\n    try {\n      result = JSON.parse(data);\n    } catch (e) {\n      _this.lastChunk = data; // start timeout to cancel all requests\n\n      clearTimeout(_this.lastChunkTimeout);\n      _this.lastChunkTimeout = setTimeout(function () {\n        _this._timeout();\n\n        throw errors.InvalidResponse(data);\n      }, 1000 * 15);\n      return;\n    } // cancel timeout and set chunk to null\n\n\n    clearTimeout(_this.lastChunkTimeout);\n    _this.lastChunk = null;\n\n    if (result) {\n      returnValues.push(result);\n    }\n  });\n  return returnValues;\n};\n/**\n Adds a callback to the responseCallbacks object,\n which will be called if a response matching the response Id will arrive.\n\n @method _addResponseCallback\n */\n\n\nWebsocketProvider.prototype._addResponseCallback = function (payload, callback) {\n  var id = payload.id || payload[0].id;\n  var method = payload.method || payload[0].method;\n  this.responseCallbacks[id] = callback;\n  this.responseCallbacks[id].method = method;\n\n  var _this = this; // schedule triggering the error response if a custom timeout is set\n\n\n  if (this._customTimeout) {\n    setTimeout(function () {\n      if (_this.responseCallbacks[id]) {\n        _this.responseCallbacks[id](errors.ConnectionTimeout(_this._customTimeout));\n\n        delete _this.responseCallbacks[id];\n      }\n    }, this._customTimeout);\n  }\n};\n/**\n Timeout all requests when the end/error event is fired\n\n @method _timeout\n */\n\n\nWebsocketProvider.prototype._timeout = function () {\n  for (var key in this.responseCallbacks) {\n    if (Object.prototype.hasOwnProperty.call(this.responseCallbacks, key)) {\n      this.responseCallbacks[key](errors.InvalidConnection('on WS'));\n      delete this.responseCallbacks[key];\n    }\n  }\n};\n\nWebsocketProvider.prototype.send = function (payload, callback) {\n  var _this = this;\n\n  if (this.connection.readyState === this.connection.CONNECTING) {\n    setTimeout(function () {\n      _this.send(payload, callback);\n    }, 10);\n    return;\n  } // try reconnect, when connection is gone\n  // if(!this.connection.writable)\n  //     this.connection.connect({url: this.url});\n\n\n  if (this.connection.readyState !== this.connection.OPEN) {\n    console.error('connection not open on send()');\n\n    if (typeof this.connection.onerror === 'function') {\n      this.connection.onerror(new Error('connection not open'));\n    } else {\n      console.error('no error callback');\n    } // reconnect\n\n\n    this.connection = this.reconnect();\n    callback(new Error('connection not open. try reconnect..'));\n    return;\n  }\n\n  this.connection.send(JSON.stringify(payload));\n\n  this._addResponseCallback(payload, callback);\n};\n/**\n Subscribes to provider events.provider\n\n @method on\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n @param {Function} callback   the callback to call\n */\n\n\nWebsocketProvider.prototype.on = function (type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('The second parameter callback must be a function.');\n  }\n\n  switch (type) {\n    case 'data':\n      this.notificationCallbacks.push(callback);\n      break;\n\n    case 'connect':\n      this.connection.onopen = callback;\n      break;\n\n    case 'end':\n      this.connection.onclose = callback;\n      break;\n\n    case 'error':\n      this.connection.onerror = callback;\n      break;\n    // default:\n    //     this.connection.on(type, callback);\n    //     break;\n  }\n}; // TODO add once\n\n/**\n Removes event listener\n\n @method removeListener\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n @param {Function} callback   the callback to call\n */\n\n\nWebsocketProvider.prototype.removeListener = function (type, callback) {\n  var _this = this;\n\n  switch (type) {\n    case 'data':\n      this.notificationCallbacks.forEach(function (cb, index) {\n        if (cb === callback) {\n          _this.notificationCallbacks.splice(index, 1);\n        }\n      });\n      break;\n    // TODO remvoving connect missing\n    // default:\n    //     this.connection.removeListener(type, callback);\n    //     break;\n  }\n};\n/**\n Removes all event listeners\n\n @method removeAllListeners\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n */\n\n\nWebsocketProvider.prototype.removeAllListeners = function (type) {\n  switch (type) {\n    case 'data':\n      this.notificationCallbacks = [];\n      break;\n    // TODO remvoving connect properly missing\n\n    case 'connect':\n      this.connection.onopen = null;\n      break;\n\n    case 'end':\n      this.connection.onclose = null;\n      break;\n\n    case 'error':\n      this.connection.onerror = null;\n      break;\n\n    default:\n      // this.connection.removeAllListeners(type);\n      break;\n  }\n};\n/**\n Resets the providers, clears all callbacks\n\n @method reset\n */\n\n\nWebsocketProvider.prototype.reset = function () {\n  this._timeout();\n\n  this.notificationCallbacks = []; // this.connection.removeAllListeners('error');\n  // this.connection.removeAllListeners('end');\n  // this.connection.removeAllListeners('timeout');\n\n  this.addDefaultEvents();\n};\n\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n  return true;\n};\n\nmodule.exports = WebsocketProvider;","map":{"version":3,"sources":["C:/Users/MONK/Desktop/Pro/client/node_modules/caver-js/packages/caver-core-requestmanager/caver-providers-ws/src/index.js"],"names":["_","require","errors","Ws","_btoa","parseURL","window","WebSocket","btoa","url","URL","w3cwebsocket","str","Buffer","from","toString","newURL","u","parse","WebsocketProvider","options","_this","responseCallbacks","notificationCallbacks","_customTimeout","timeout","parsedURL","headers","protocol","undefined","username","password","authorization","clientConfig","connection","reconnect","addDefaultEvents","onmessage","e","data","_parseResponse","forEach","result","id","isArray","load","method","indexOf","callback","isFunction","prototype","onerror","_timeout","onclose","reset","response","returnValues","dechunkedData","replace","split","lastChunk","JSON","clearTimeout","lastChunkTimeout","setTimeout","InvalidResponse","push","_addResponseCallback","payload","ConnectionTimeout","key","Object","hasOwnProperty","call","InvalidConnection","send","readyState","CONNECTING","OPEN","console","error","Error","stringify","on","type","onopen","removeListener","cb","index","splice","removeAllListeners","supportsSubscriptions","module","exports"],"mappings":"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","sourcesContent":["/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-providers-ws/src/index.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n/** @file WebsocketProvider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst errors = require('../../../caver-core-helpers').errors\n\nlet Ws = null\nlet _btoa = null\nlet parseURL = null\n/* eslint-disable no-undef */\nif (typeof window !== 'undefined' && typeof window.WebSocket !== 'undefined') {\n    Ws = window.WebSocket\n    _btoa = btoa\n    parseURL = function(url) {\n        return new URL(url)\n    }\n} else {\n    Ws = require('websocket').w3cwebsocket\n    _btoa = function(str) {\n        return Buffer.from(str).toString('base64')\n    }\n    const url = require('url')\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        const newURL = url.URL\n        parseURL = function(u) {\n            return new newURL(u)\n        }\n    } else {\n        parseURL = require('url').parse\n    }\n}\n// Default connection ws://localhost:8546\n\nconst WebsocketProvider = function WebsocketProvider(url, options) {\n    const _this = this\n    this.responseCallbacks = {}\n    this.notificationCallbacks = []\n\n    options = options || {}\n    this._customTimeout = options.timeout\n\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    const parsedURL = parseURL(url)\n    const headers = options.headers || {}\n    const protocol = options.protocol || undefined\n    if (parsedURL.username && parsedURL.password) {\n        headers.authorization = `Basic ${_btoa(`${parsedURL.username}:${parsedURL.password}`)}`\n    }\n\n    // Allow a custom client configuration\n    const clientConfig = options.clientConfig || undefined\n\n    this.connection = new Ws(url, protocol, undefined, headers, undefined, clientConfig)\n    this.reconnect = () => new Ws(url, protocol, undefined, headers, undefined, clientConfig)\n\n    this.addDefaultEvents()\n\n    // LISTEN FOR CONNECTION RESPONSES\n    this.connection.onmessage = function(e) {\n        const data = typeof e.data === 'string' ? e.data : ''\n\n        _this._parseResponse(data).forEach(function(result) {\n            let id = null\n\n            // get the id which matches the returned id\n            if (_.isArray(result)) {\n                result.forEach(function(load) {\n                    if (_this.responseCallbacks[load.id]) {\n                        id = load.id\n                    }\n                })\n            } else {\n                id = result.id\n            }\n\n            // notification\n            if (!id && result.method.indexOf('_subscription') !== -1) {\n                _this.notificationCallbacks.forEach(function(callback) {\n                    if (_.isFunction(callback)) {\n                        callback(result)\n                    }\n                })\n\n                // fire the callback\n            } else if (_this.responseCallbacks[id]) {\n                _this.responseCallbacks[id](null, result)\n                delete _this.responseCallbacks[id]\n            }\n        })\n    }\n}\n\n/**\n Will add the error and end event to timeout existing calls\n\n @method addDefaultEvents\n */\nWebsocketProvider.prototype.addDefaultEvents = function() {\n    const _this = this\n\n    this.connection.onerror = function() {\n        _this._timeout()\n    }\n\n    this.connection.onclose = function() {\n        _this._timeout()\n\n        // reset all requests and callbacks\n        _this.reset()\n    }\n\n    // this.connection.on('timeout', function(){\n    //     _this._timeout();\n    // });\n}\n\n/**\n Will parse the response and make an array out of it.\n\n @method _parseResponse\n @param {String} response\n */\nWebsocketProvider.prototype._parseResponse = function(response) {\n    const _this = this\n    const returnValues = []\n\n    // DE-CHUNKER\n    const dechunkedData = response\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|')\n\n    dechunkedData.forEach(function(data) {\n        // prepend the last chunk\n        if (_this.lastChunk) {\n            data = _this.lastChunk + data\n        }\n\n        let result = null\n\n        try {\n            result = JSON.parse(data)\n        } catch (e) {\n            _this.lastChunk = data\n\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout)\n            _this.lastChunkTimeout = setTimeout(function() {\n                _this._timeout()\n                throw errors.InvalidResponse(data)\n            }, 1000 * 15)\n\n            return\n        }\n\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout)\n        _this.lastChunk = null\n\n        if (result) {\n            returnValues.push(result)\n        }\n    })\n\n    return returnValues\n}\n\n/**\n Adds a callback to the responseCallbacks object,\n which will be called if a response matching the response Id will arrive.\n\n @method _addResponseCallback\n */\nWebsocketProvider.prototype._addResponseCallback = function(payload, callback) {\n    const id = payload.id || payload[0].id\n    const method = payload.method || payload[0].method\n\n    this.responseCallbacks[id] = callback\n    this.responseCallbacks[id].method = method\n\n    const _this = this\n\n    // schedule triggering the error response if a custom timeout is set\n    if (this._customTimeout) {\n        setTimeout(function() {\n            if (_this.responseCallbacks[id]) {\n                _this.responseCallbacks[id](errors.ConnectionTimeout(_this._customTimeout))\n                delete _this.responseCallbacks[id]\n            }\n        }, this._customTimeout)\n    }\n}\n\n/**\n Timeout all requests when the end/error event is fired\n\n @method _timeout\n */\nWebsocketProvider.prototype._timeout = function() {\n    for (const key in this.responseCallbacks) {\n        if (Object.prototype.hasOwnProperty.call(this.responseCallbacks, key)) {\n            this.responseCallbacks[key](errors.InvalidConnection('on WS'))\n            delete this.responseCallbacks[key]\n        }\n    }\n}\n\nWebsocketProvider.prototype.send = function(payload, callback) {\n    const _this = this\n\n    if (this.connection.readyState === this.connection.CONNECTING) {\n        setTimeout(function() {\n            _this.send(payload, callback)\n        }, 10)\n        return\n    }\n\n    // try reconnect, when connection is gone\n    // if(!this.connection.writable)\n    //     this.connection.connect({url: this.url});\n    if (this.connection.readyState !== this.connection.OPEN) {\n        console.error('connection not open on send()')\n        if (typeof this.connection.onerror === 'function') {\n            this.connection.onerror(new Error('connection not open'))\n        } else {\n            console.error('no error callback')\n        }\n        // reconnect\n        this.connection = this.reconnect()\n        callback(new Error('connection not open. try reconnect..'))\n        return\n    }\n\n    this.connection.send(JSON.stringify(payload))\n    this._addResponseCallback(payload, callback)\n}\n\n/**\n Subscribes to provider events.provider\n\n @method on\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n @param {Function} callback   the callback to call\n */\nWebsocketProvider.prototype.on = function(type, callback) {\n    if (typeof callback !== 'function') {\n        throw new Error('The second parameter callback must be a function.')\n    }\n\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks.push(callback)\n            break\n\n        case 'connect':\n            this.connection.onopen = callback\n            break\n\n        case 'end':\n            this.connection.onclose = callback\n            break\n\n        case 'error':\n            this.connection.onerror = callback\n            break\n\n        // default:\n        //     this.connection.on(type, callback);\n        //     break;\n    }\n}\n\n// TODO add once\n\n/**\n Removes event listener\n\n @method removeListener\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n @param {Function} callback   the callback to call\n */\nWebsocketProvider.prototype.removeListener = function(type, callback) {\n    const _this = this\n\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks.forEach(function(cb, index) {\n                if (cb === callback) {\n                    _this.notificationCallbacks.splice(index, 1)\n                }\n            })\n            break\n\n        // TODO remvoving connect missing\n\n        // default:\n        //     this.connection.removeListener(type, callback);\n        //     break;\n    }\n}\n\n/**\n Removes all event listeners\n\n @method removeAllListeners\n @param {String} type    'notifcation', 'connect', 'error', 'end' or 'data'\n */\nWebsocketProvider.prototype.removeAllListeners = function(type) {\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks = []\n            break\n\n        // TODO remvoving connect properly missing\n\n        case 'connect':\n            this.connection.onopen = null\n            break\n\n        case 'end':\n            this.connection.onclose = null\n            break\n\n        case 'error':\n            this.connection.onerror = null\n            break\n\n        default:\n            // this.connection.removeAllListeners(type);\n            break\n    }\n}\n\n/**\n Resets the providers, clears all callbacks\n\n @method reset\n */\nWebsocketProvider.prototype.reset = function() {\n    this._timeout()\n    this.notificationCallbacks = []\n\n    // this.connection.removeAllListeners('error');\n    // this.connection.removeAllListeners('end');\n    // this.connection.removeAllListeners('timeout');\n\n    this.addDefaultEvents()\n}\n\nWebsocketProvider.prototype.supportsSubscriptions = function() {\n    return true\n}\n\nmodule.exports = WebsocketProvider\n"]},"metadata":{},"sourceType":"script"}