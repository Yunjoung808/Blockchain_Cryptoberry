{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-helpers/src/formatters.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar utils = require('../../caver-utils');\n\nvar validateParams = require('../../caver-core-helpers/src/validateFunction').validateParams;\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n * @param {String|Number|BigNumber} number\n * @returns {BigNumber} object\n */\n\n\nvar outputBigNumberFormatter = function outputBigNumberFormatter(number) {\n  return utils.toBN(number).toString(10);\n};\n\nvar inputDefaultBlockNumberFormatter = function inputDefaultBlockNumberFormatter(blockNumber) {\n  if (this && (blockNumber === undefined || blockNumber === null)) {\n    return utils.parsePredefinedBlockNumber(this.defaultBlock) || 'latest';\n  }\n\n  return inputBlockNumberFormatter(blockNumber);\n};\n\nvar inputBlockNumberFormatter = function inputBlockNumberFormatter(blockNumber) {\n  if (blockNumber === undefined) {\n    return undefined;\n  }\n\n  if (utils.isPredefinedBlockNumber(blockNumber)) {\n    return utils.parsePredefinedBlockNumber(blockNumber);\n  }\n\n  return utils.isHexStrict(blockNumber) ? _.isString(blockNumber) ? blockNumber.toLowerCase() : blockNumber : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nvar _txInputFormatter = function _txInputFormatter(options) {\n  if (options.from) {\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.to) {\n    options.humanReadable = options.humanReadable !== undefined ? options.humanReadable : false;\n    if (options.humanReadable) throw new Error('HumanReadableAddress is not supported yet.');\n\n    if (!utils.isContractDeployment(options) || options.to !== '0x') {\n      options.to = inputAddressFormatter(options.to);\n    }\n  }\n\n  if (options.data && options.input) {\n    throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n  }\n\n  if (!options.data && options.input) {\n    options.data = options.input;\n    delete options.input;\n  }\n\n  if (options.data && !utils.isHex(options.data)) {\n    options.data = utils.toHex(options.data);\n  } // allow both\n\n\n  if (options.gas || options.gasLimit) {\n    options.gas = options.gas || options.gasLimit;\n  }\n\n  var fieldToBeHex = ['gasPrice', 'gas', 'value', 'nonce', 'feeRatio'];\n  fieldToBeHex.filter(function (key) {\n    return options[key] !== undefined;\n  }).forEach(function (key) {\n    options[key] = utils.numberToHex(options[key]);\n  });\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nvar inputCallFormatter = function inputCallFormatter(options) {\n  options = _txInputFormatter(options);\n  var from = options.from || (this ? this.defaultAccount : null);\n\n  if (from) {\n    options.from = inputAddressFormatter(from);\n  }\n\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\n\n\nvar inputTransactionFormatter = function inputTransactionFormatter(options) {\n  options = _txInputFormatter(options); // If senderRawTransaction' exist in transaction, it means object is fee payer transaction format like below\n  // { senderRawTransaction: '', feePayer: '' }\n\n  if (options.senderRawTransaction) {\n    if (options.feePayer === undefined) {\n      throw new Error('The \"feePayer\" field must be defined for signing with feePayer!');\n    }\n\n    options.feePayer = inputAddressFormatter(options.feePayer);\n    return options;\n  } // check from, only if not number, or object\n\n\n  if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n\n    if (!options.from && !_.isNumber(options.from)) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.data) {\n    options.data = utils.addHexPrefix(options.data);\n  }\n\n  var err = validateParams(options);\n\n  if (err) {\n    throw err;\n  }\n\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputPersonalTransactionFormatter\n * @param {Object} options\n * @returns object\n */\n\n\nvar inputPersonalTransactionFormatter = function inputPersonalTransactionFormatter(options) {\n  options = _txInputFormatter(options); // check from, only if not number, or object\n\n  if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n\n    if (!options.from && !_.isNumber(options.from)) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.data) {\n    options.data = utils.addHexPrefix(options.data);\n  }\n\n  return options;\n};\n/**\n * Hex encodes the data passed to klay_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\n\n\nvar inputSignFormatter = function inputSignFormatter(data) {\n  return utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\n\n\nvar outputTransactionFormatter = function outputTransactionFormatter(tx) {\n  if (!tx) return null;\n\n  if (tx.blockNumber !== undefined) {\n    tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n  }\n\n  if (tx.transactionIndex !== undefined) {\n    tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n  }\n\n  tx.nonce = utils.hexToNumber(tx.nonce);\n  tx.gas = utils.hexToNumber(tx.gas);\n  tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n\n  if (tx.value) {\n    tx.value = outputBigNumberFormatter(tx.value);\n  }\n\n  if (tx.to && utils.isAddress(tx.to)) {\n    // tx.to could be `0x0` or `null` while contract creation\n    tx.to = utils.toChecksumAddress(tx.to);\n  } else {\n    tx.to = null; // set to `null` if invalid address\n  }\n\n  if (tx.from) {\n    tx.from = utils.toChecksumAddress(tx.from);\n  }\n\n  return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\n\n\nvar outputTransactionReceiptFormatter = function outputTransactionReceiptFormatter(receipt) {\n  if (!receipt) return null;\n\n  if (typeof receipt !== 'object') {\n    throw new Error(\"Received receipt is invalid: \".concat(receipt));\n  }\n\n  if (receipt.blockNumber !== undefined) {\n    receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n  }\n\n  if (receipt.transactionIndex !== undefined) {\n    receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n  }\n\n  receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n\n  if (_.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n\n  if (receipt.contractAddress) {\n    receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n  }\n\n  if (typeof receipt.status !== 'undefined') {\n    receipt.status = parseInt(receipt.status) === 1;\n  }\n\n  return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\n\n\nvar outputBlockFormatter = function outputBlockFormatter(block) {\n  // transform to number\n  block.gasLimit = utils.hexToNumber(block.gasLimit);\n  block.gasUsed = utils.hexToNumber(block.gasUsed);\n  block.size = utils.hexToNumber(block.size);\n  block.timestamp = utils.hexToNumber(block.timestamp);\n\n  if (block.number !== undefined) {\n    block.number = utils.hexToNumber(block.number);\n  }\n\n  if (block.difficulty) {\n    block.difficulty = outputBigNumberFormatter(block.difficulty);\n  }\n\n  if (block.totalDifficulty) {\n    block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n  }\n\n  if (_.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (!_.isString(item)) {\n        return outputTransactionFormatter(item);\n      }\n    });\n  }\n\n  if (block.miner) {\n    block.miner = utils.toChecksumAddress(block.miner);\n  }\n\n  return block;\n};\n/**\n * inputLogFormatter's inner function\n * format topic values\n */\n\n\nvar toTopic = function toTopic(value) {\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  value = String(value); // If value is not hex string, return it\n\n  if (value.indexOf('0x') === 0) {\n    return value;\n  }\n\n  return utils.fromUtf8(value);\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nvar inputLogFormatter = function inputLogFormatter(options) {\n  // make sure topics, get converted to hex\n  options.topics = (options.topics || []).map(topic => _.isArray(topic) ? topic.map(toTopic) : toTopic(topic));\n\n  if (options.address) {\n    options.address = _.isArray(options.address) ? options.address.map(addr => inputAddressFormatter(addr)) : inputAddressFormatter(options.address);\n  } // if `fromBlock`, `toBlock` type is number, convert it to hex string.\n\n\n  options.fromBlock = typeof options.fromBlock === 'number' ? utils.numberToHex(options.fromBlock) : options.fromBlock;\n  options.toBlock = typeof options.toBlock === 'number' ? utils.numberToHex(options.toBlock) : options.toBlock;\n  return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nvar outputLogFormatter = function outputLogFormatter(log) {\n  // `removed` field is unnecessary,\n  // since it isn't possible for block to be removed in Klaytn consensus scenario.\n  delete log.removed; // generate a custom log id\n\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n    log.id = \"log_\".concat(shaId.replace('0x', '').substr(0, 8));\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== undefined) {\n    log.blockNumber = utils.hexToNumber(log.blockNumber);\n  }\n\n  if (log.transactionIndex !== undefined) {\n    log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n  }\n\n  if (log.logIndex !== undefined) {\n    log.logIndex = utils.hexToNumber(log.logIndex);\n  }\n\n  if (log.address) {\n    log.address = utils.toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\n\n\nvar inputPostFormatter = function inputPostFormatter(post) {\n  // post.payload = utils.toHex(post.payload);\n  if (post.ttl) {\n    post.ttl = utils.numberToHex(post.ttl);\n  }\n\n  if (post.workToProve) {\n    post.workToProve = utils.numberToHex(post.workToProve);\n  }\n\n  if (post.priority) {\n    post.priority = utils.numberToHex(post.priority);\n  } // fallback\n\n\n  if (!_.isArray(post.topics)) {\n    post.topics = post.topics ? [post.topics] : [];\n  } // format the following options\n\n\n  post.topics = post.topics.map(function (topic) {\n    // convert only if not hex\n    return topic.indexOf('0x') === 0 ? topic : utils.fromUtf8(topic);\n  });\n  return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\n\n\nvar outputPostFormatter = function outputPostFormatter(post) {\n  post.expiry = utils.hexToNumber(post.expiry);\n  post.sent = utils.hexToNumber(post.sent);\n  post.ttl = utils.hexToNumber(post.ttl);\n  post.workProved = utils.hexToNumber(post.workProved); // post.payloadRaw = post.payload;\n  // post.payload = utils.hexToAscii(post.payload);\n  // if (utils.isJson(post.payload)) {\n  //     post.payload = JSON.parse(post.payload);\n  // }\n  // format the following options\n\n  if (!post.topics) {\n    post.topics = [];\n  }\n\n  post.topics = post.topics.map(function (topic) {\n    return utils.toUtf8(topic);\n  });\n  return post;\n};\n\nvar inputAddressFormatter = function inputAddressFormatter(address) {\n  var iban = new utils.Iban(address);\n\n  if (iban.isValid() && iban.isDirect()) {\n    return iban.toAddress().toLowerCase();\n  }\n\n  if (utils.isAddress(address)) {\n    return \"0x\".concat(address.toLowerCase().replace('0x', ''));\n  }\n\n  throw new Error(\"Provided address \\\"\".concat(address, \"\\\" is invalid, the capitalization checksum test failed.\"));\n};\n\nvar outputSyncingFormatter = function outputSyncingFormatter(result) {\n  result.startingBlock = utils.hexToNumber(result.startingBlock);\n  result.currentBlock = utils.hexToNumber(result.currentBlock);\n  result.highestBlock = utils.hexToNumber(result.highestBlock);\n\n  if (result.knownStates) {\n    result.knownStates = utils.hexToNumber(result.knownStates);\n    result.pulledStates = utils.hexToNumber(result.pulledStates);\n  }\n\n  return result;\n};\n\nvar inputRawKeyFormatter = function inputRawKeyFormatter(rawKey) {\n  if (rawKey.slice(0, 2) === '0x') rawKey = rawKey.slice(2);\n  return rawKey;\n};\n\nvar toBoolean = v => !!v;\n\nmodule.exports = {\n  inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n  inputBlockNumberFormatter: inputBlockNumberFormatter,\n  inputCallFormatter: inputCallFormatter,\n  inputTransactionFormatter: inputTransactionFormatter,\n  inputPersonalTransactionFormatter: inputPersonalTransactionFormatter,\n  inputAddressFormatter: inputAddressFormatter,\n  inputPostFormatter: inputPostFormatter,\n  inputLogFormatter: inputLogFormatter,\n  inputSignFormatter: inputSignFormatter,\n  inputRawKeyFormatter: inputRawKeyFormatter,\n  outputBigNumberFormatter: outputBigNumberFormatter,\n  outputTransactionFormatter: outputTransactionFormatter,\n  outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n  outputBlockFormatter: outputBlockFormatter,\n  outputLogFormatter: outputLogFormatter,\n  outputPostFormatter: outputPostFormatter,\n  outputSyncingFormatter: outputSyncingFormatter,\n  // moved from util\n  toChecksumAddress: utils.toChecksumAddress,\n  hexToNumber: utils.hexToNumber,\n  numberToHex: utils.numberToHex,\n  toBoolean: toBoolean\n};","map":{"version":3,"sources":["C:/Users/MONK/Desktop/Pro/client/node_modules/caver-js/packages/caver-core-helpers/src/formatters.js"],"names":["_","require","utils","validateParams","outputBigNumberFormatter","number","toBN","toString","inputDefaultBlockNumberFormatter","blockNumber","undefined","parsePredefinedBlockNumber","defaultBlock","inputBlockNumberFormatter","isPredefinedBlockNumber","isHexStrict","isString","toLowerCase","numberToHex","_txInputFormatter","options","from","inputAddressFormatter","to","humanReadable","Error","isContractDeployment","data","input","isHex","toHex","gas","gasLimit","fieldToBeHex","filter","key","forEach","inputCallFormatter","defaultAccount","inputTransactionFormatter","senderRawTransaction","feePayer","isNumber","isObject","addHexPrefix","err","inputPersonalTransactionFormatter","inputSignFormatter","utf8ToHex","outputTransactionFormatter","tx","hexToNumber","transactionIndex","nonce","gasPrice","value","isAddress","toChecksumAddress","outputTransactionReceiptFormatter","receipt","gasUsed","isArray","logs","map","outputLogFormatter","contractAddress","status","parseInt","outputBlockFormatter","block","size","timestamp","difficulty","totalDifficulty","transactions","item","miner","toTopic","String","indexOf","fromUtf8","inputLogFormatter","topics","topic","address","addr","fromBlock","toBlock","log","removed","blockHash","transactionHash","logIndex","shaId","sha3","replace","id","substr","inputPostFormatter","post","ttl","workToProve","priority","outputPostFormatter","expiry","sent","workProved","toUtf8","iban","Iban","isValid","isDirect","toAddress","outputSyncingFormatter","result","startingBlock","currentBlock","highestBlock","knownStates","pulledStates","inputRawKeyFormatter","rawKey","slice","toBoolean","v","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-helpers/src/formatters.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst utils = require('../../caver-utils')\nconst validateParams = require('../../caver-core-helpers/src/validateFunction').validateParams\n\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n * @param {String|Number|BigNumber} number\n * @returns {BigNumber} object\n */\nconst outputBigNumberFormatter = function(number) {\n    return utils.toBN(number).toString(10)\n}\n\nconst inputDefaultBlockNumberFormatter = function(blockNumber) {\n    if (this && (blockNumber === undefined || blockNumber === null)) {\n        return utils.parsePredefinedBlockNumber(this.defaultBlock) || 'latest'\n    }\n    return inputBlockNumberFormatter(blockNumber)\n}\n\nconst inputBlockNumberFormatter = function(blockNumber) {\n    if (blockNumber === undefined) {\n        return undefined\n    }\n    if (utils.isPredefinedBlockNumber(blockNumber)) {\n        return utils.parsePredefinedBlockNumber(blockNumber)\n    }\n    return utils.isHexStrict(blockNumber)\n        ? _.isString(blockNumber)\n            ? blockNumber.toLowerCase()\n            : blockNumber\n        : utils.numberToHex(blockNumber)\n}\n\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\nconst _txInputFormatter = function(options) {\n    if (options.from) {\n        options.from = inputAddressFormatter(options.from)\n    }\n\n    if (options.to) {\n        options.humanReadable = options.humanReadable !== undefined ? options.humanReadable : false\n        if (options.humanReadable) throw new Error('HumanReadableAddress is not supported yet.')\n        if (!utils.isContractDeployment(options) || options.to !== '0x') {\n            options.to = inputAddressFormatter(options.to)\n        }\n    }\n\n    if (options.data && options.input) {\n        throw new Error(\n            'You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.'\n        )\n    }\n\n    if (!options.data && options.input) {\n        options.data = options.input\n        delete options.input\n    }\n\n    if (options.data && !utils.isHex(options.data)) {\n        options.data = utils.toHex(options.data)\n    }\n\n    // allow both\n    if (options.gas || options.gasLimit) {\n        options.gas = options.gas || options.gasLimit\n    }\n\n    const fieldToBeHex = ['gasPrice', 'gas', 'value', 'nonce', 'feeRatio']\n\n    fieldToBeHex\n        .filter(function(key) {\n            return options[key] !== undefined\n        })\n        .forEach(function(key) {\n            options[key] = utils.numberToHex(options[key])\n        })\n\n    return options\n}\n\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\nconst inputCallFormatter = function(options) {\n    options = _txInputFormatter(options)\n\n    const from = options.from || (this ? this.defaultAccount : null)\n\n    if (from) {\n        options.from = inputAddressFormatter(from)\n    }\n\n    return options\n}\n\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\nconst inputTransactionFormatter = function(options) {\n    options = _txInputFormatter(options)\n\n    // If senderRawTransaction' exist in transaction, it means object is fee payer transaction format like below\n    // { senderRawTransaction: '', feePayer: '' }\n    if (options.senderRawTransaction) {\n        if (options.feePayer === undefined) {\n            throw new Error('The \"feePayer\" field must be defined for signing with feePayer!')\n        }\n        options.feePayer = inputAddressFormatter(options.feePayer)\n        return options\n    }\n\n    // check from, only if not number, or object\n    if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n        options.from = options.from || (this ? this.defaultAccount : null)\n\n        if (!options.from && !_.isNumber(options.from)) {\n            throw new Error('The send transactions \"from\" field must be defined!')\n        }\n\n        options.from = inputAddressFormatter(options.from)\n    }\n\n    if (options.data) {\n        options.data = utils.addHexPrefix(options.data)\n    }\n\n    const err = validateParams(options)\n    if (err) {\n        throw err\n    }\n\n    return options\n}\n\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputPersonalTransactionFormatter\n * @param {Object} options\n * @returns object\n */\nconst inputPersonalTransactionFormatter = function(options) {\n    options = _txInputFormatter(options)\n\n    // check from, only if not number, or object\n    if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n        options.from = options.from || (this ? this.defaultAccount : null)\n\n        if (!options.from && !_.isNumber(options.from)) {\n            throw new Error('The send transactions \"from\" field must be defined!')\n        }\n\n        options.from = inputAddressFormatter(options.from)\n    }\n\n    if (options.data) {\n        options.data = utils.addHexPrefix(options.data)\n    }\n\n    return options\n}\n\n/**\n * Hex encodes the data passed to klay_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\nconst inputSignFormatter = function(data) {\n    return utils.isHexStrict(data) ? data : utils.utf8ToHex(data)\n}\n\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\nconst outputTransactionFormatter = function(tx) {\n    if (!tx) return null\n\n    if (tx.blockNumber !== undefined) {\n        tx.blockNumber = utils.hexToNumber(tx.blockNumber)\n    }\n    if (tx.transactionIndex !== undefined) {\n        tx.transactionIndex = utils.hexToNumber(tx.transactionIndex)\n    }\n    tx.nonce = utils.hexToNumber(tx.nonce)\n    tx.gas = utils.hexToNumber(tx.gas)\n    tx.gasPrice = outputBigNumberFormatter(tx.gasPrice)\n    if (tx.value) {\n        tx.value = outputBigNumberFormatter(tx.value)\n    }\n\n    if (tx.to && utils.isAddress(tx.to)) {\n        // tx.to could be `0x0` or `null` while contract creation\n        tx.to = utils.toChecksumAddress(tx.to)\n    } else {\n        tx.to = null // set to `null` if invalid address\n    }\n\n    if (tx.from) {\n        tx.from = utils.toChecksumAddress(tx.from)\n    }\n\n    return tx\n}\n\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\nconst outputTransactionReceiptFormatter = function(receipt) {\n    if (!receipt) return null\n\n    if (typeof receipt !== 'object') {\n        throw new Error(`Received receipt is invalid: ${receipt}`)\n    }\n\n    if (receipt.blockNumber !== undefined) {\n        receipt.blockNumber = utils.hexToNumber(receipt.blockNumber)\n    }\n    if (receipt.transactionIndex !== undefined) {\n        receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex)\n    }\n    receipt.gasUsed = utils.hexToNumber(receipt.gasUsed)\n\n    if (_.isArray(receipt.logs)) {\n        receipt.logs = receipt.logs.map(outputLogFormatter)\n    }\n\n    if (receipt.contractAddress) {\n        receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress)\n    }\n\n    if (typeof receipt.status !== 'undefined') {\n        receipt.status = parseInt(receipt.status) === 1\n    }\n\n    return receipt\n}\n\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\nconst outputBlockFormatter = function(block) {\n    // transform to number\n    block.gasLimit = utils.hexToNumber(block.gasLimit)\n    block.gasUsed = utils.hexToNumber(block.gasUsed)\n    block.size = utils.hexToNumber(block.size)\n    block.timestamp = utils.hexToNumber(block.timestamp)\n    if (block.number !== undefined) {\n        block.number = utils.hexToNumber(block.number)\n    }\n\n    if (block.difficulty) {\n        block.difficulty = outputBigNumberFormatter(block.difficulty)\n    }\n    if (block.totalDifficulty) {\n        block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty)\n    }\n\n    if (_.isArray(block.transactions)) {\n        block.transactions.forEach(function(item) {\n            if (!_.isString(item)) {\n                return outputTransactionFormatter(item)\n            }\n        })\n    }\n\n    if (block.miner) {\n        block.miner = utils.toChecksumAddress(block.miner)\n    }\n\n    return block\n}\n\n/**\n * inputLogFormatter's inner function\n * format topic values\n */\nconst toTopic = function(value) {\n    if (value === null || typeof value === 'undefined') {\n        return null\n    }\n\n    value = String(value)\n\n    // If value is not hex string, return it\n    if (value.indexOf('0x') === 0) {\n        return value\n    }\n    return utils.fromUtf8(value)\n}\n\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nconst inputLogFormatter = function(options) {\n    // make sure topics, get converted to hex\n    options.topics = (options.topics || []).map(topic => (_.isArray(topic) ? topic.map(toTopic) : toTopic(topic)))\n\n    if (options.address) {\n        options.address = _.isArray(options.address)\n            ? options.address.map(addr => inputAddressFormatter(addr))\n            : inputAddressFormatter(options.address)\n    }\n\n    // if `fromBlock`, `toBlock` type is number, convert it to hex string.\n\n    options.fromBlock = typeof options.fromBlock === 'number' ? utils.numberToHex(options.fromBlock) : options.fromBlock\n\n    options.toBlock = typeof options.toBlock === 'number' ? utils.numberToHex(options.toBlock) : options.toBlock\n\n    return options\n}\n\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nconst outputLogFormatter = function(log) {\n    // `removed` field is unnecessary,\n    // since it isn't possible for block to be removed in Klaytn consensus scenario.\n    delete log.removed\n\n    // generate a custom log id\n    if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n        const shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''))\n        log.id = `log_${shaId.replace('0x', '').substr(0, 8)}`\n    } else if (!log.id) {\n        log.id = null\n    }\n\n    if (log.blockNumber !== undefined) {\n        log.blockNumber = utils.hexToNumber(log.blockNumber)\n    }\n    if (log.transactionIndex !== undefined) {\n        log.transactionIndex = utils.hexToNumber(log.transactionIndex)\n    }\n    if (log.logIndex !== undefined) {\n        log.logIndex = utils.hexToNumber(log.logIndex)\n    }\n    if (log.address) {\n        log.address = utils.toChecksumAddress(log.address)\n    }\n\n    return log\n}\n\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\nconst inputPostFormatter = function(post) {\n    // post.payload = utils.toHex(post.payload);\n\n    if (post.ttl) {\n        post.ttl = utils.numberToHex(post.ttl)\n    }\n    if (post.workToProve) {\n        post.workToProve = utils.numberToHex(post.workToProve)\n    }\n    if (post.priority) {\n        post.priority = utils.numberToHex(post.priority)\n    }\n\n    // fallback\n    if (!_.isArray(post.topics)) {\n        post.topics = post.topics ? [post.topics] : []\n    }\n\n    // format the following options\n    post.topics = post.topics.map(function(topic) {\n        // convert only if not hex\n        return topic.indexOf('0x') === 0 ? topic : utils.fromUtf8(topic)\n    })\n\n    return post\n}\n\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\nconst outputPostFormatter = function(post) {\n    post.expiry = utils.hexToNumber(post.expiry)\n    post.sent = utils.hexToNumber(post.sent)\n    post.ttl = utils.hexToNumber(post.ttl)\n    post.workProved = utils.hexToNumber(post.workProved)\n    // post.payloadRaw = post.payload;\n    // post.payload = utils.hexToAscii(post.payload);\n\n    // if (utils.isJson(post.payload)) {\n    //     post.payload = JSON.parse(post.payload);\n    // }\n\n    // format the following options\n    if (!post.topics) {\n        post.topics = []\n    }\n    post.topics = post.topics.map(function(topic) {\n        return utils.toUtf8(topic)\n    })\n\n    return post\n}\n\nconst inputAddressFormatter = function(address) {\n    const iban = new utils.Iban(address)\n    if (iban.isValid() && iban.isDirect()) {\n        return iban.toAddress().toLowerCase()\n    }\n    if (utils.isAddress(address)) {\n        return `0x${address.toLowerCase().replace('0x', '')}`\n    }\n\n    throw new Error(`Provided address \"${address}\" is invalid, the capitalization checksum test failed.`)\n}\n\nconst outputSyncingFormatter = function(result) {\n    result.startingBlock = utils.hexToNumber(result.startingBlock)\n    result.currentBlock = utils.hexToNumber(result.currentBlock)\n    result.highestBlock = utils.hexToNumber(result.highestBlock)\n    if (result.knownStates) {\n        result.knownStates = utils.hexToNumber(result.knownStates)\n        result.pulledStates = utils.hexToNumber(result.pulledStates)\n    }\n\n    return result\n}\n\nconst inputRawKeyFormatter = function(rawKey) {\n    if (rawKey.slice(0, 2) === '0x') rawKey = rawKey.slice(2)\n    return rawKey\n}\n\nconst toBoolean = v => !!v\n\nmodule.exports = {\n    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n    inputBlockNumberFormatter: inputBlockNumberFormatter,\n    inputCallFormatter: inputCallFormatter,\n    inputTransactionFormatter: inputTransactionFormatter,\n    inputPersonalTransactionFormatter: inputPersonalTransactionFormatter,\n    inputAddressFormatter: inputAddressFormatter,\n    inputPostFormatter: inputPostFormatter,\n    inputLogFormatter: inputLogFormatter,\n    inputSignFormatter: inputSignFormatter,\n    inputRawKeyFormatter: inputRawKeyFormatter,\n    outputBigNumberFormatter: outputBigNumberFormatter,\n    outputTransactionFormatter: outputTransactionFormatter,\n    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n    outputBlockFormatter: outputBlockFormatter,\n    outputLogFormatter: outputLogFormatter,\n    outputPostFormatter: outputPostFormatter,\n    outputSyncingFormatter: outputSyncingFormatter,\n    // moved from util\n    toChecksumAddress: utils.toChecksumAddress,\n    hexToNumber: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    toBoolean: toBoolean,\n}\n"]},"metadata":{},"sourceType":"script"}