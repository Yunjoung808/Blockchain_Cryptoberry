{"ast":null,"code":"var _slicedToArray = require(\"C:/Users/MONK/Desktop/Cryptoberry(db)/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MONK/Desktop/Cryptoberry(db)/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\n/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar Promise = require('any-promise'); // account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\n\n\nvar AccountLib = require('eth-lib/lib/account');\n\nvar Hash = require('eth-lib/lib/hash');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar Nat = require('eth-lib/lib/nat');\n\nvar Bytes = require('eth-lib/lib/bytes');\n\nvar cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nvar uuid = require('uuid');\n\nvar elliptic = require('elliptic');\n\nvar scrypt = require('scrypt-shim');\n\nvar utils = require('../../../caver-utils');\n\nvar helpers = require('../../../caver-core-helpers');\n\nvar Method = require('../../../caver-core-method');\n\nvar core = require('../../../caver-core');\n\nvar _require = require('./makeRawTransaction'),\n    encodeRLPByTxType = _require.encodeRLPByTxType,\n    makeRawTransaction = _require.makeRawTransaction,\n    getSenderTxHash = _require.getSenderTxHash,\n    decodeFromRawTransaction = _require.decodeFromRawTransaction,\n    splitFeePayer = _require.splitFeePayer,\n    extractSignatures = _require.extractSignatures;\n\nvar secp256k1 = new elliptic.ec('secp256k1');\n\nvar AccountKeyPublic = require('./accountKey/accountKeyPublic');\n\nvar AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig');\n\nvar AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased');\n\nvar _require2 = require('./accountKey/accountKeyEnum'),\n    AccountKeyEnum = _require2.AccountKeyEnum;\n\nvar Account = require('./account/account');\n\nvar AccountForUpdate = require('./account/accountForUpdate');\n\nvar _require3 = require('../../../caver-rtm'),\n    rpc = _require3.rpc;\n\nvar isNot = function isNot(value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nfunction coverInitialTxValue(tx) {\n  if (typeof tx !== 'object') throw new Error('Invalid transaction');\n\n  if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n    tx.to = tx.to || '0x';\n    tx.data = utils.addHexPrefix(tx.data || '0x');\n  }\n\n  tx.chainId = utils.numberToHex(tx.chainId);\n  return tx;\n}\n/**\n * resolveArgsForSignTransaction parse arguments for signTransaction.\n *\n * @method resolveArgsForSignTransaction\n * @param {Object} args Parameters of signTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransaction(args) {\n  if (args.length === 0 || args.length > 3) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 2\" means that user sent parameter privateKey or callback\n\n\n  var tx = args[0];\n  var privateKey;\n  var callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (args.length === 2) {\n    if (_.isFunction(args[1])) {\n      callback = args[1];\n    } else {\n      privateKey = args[1];\n    }\n  } else if (args.length === 3) {\n    if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[1];\n    callback = args[2];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    callback\n  };\n}\n/**\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\n *\n * @method resolveArgsForFeePayerSignTransaction\n * @param {Object} args Parameters of feePayerSignTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForFeePayerSignTransaction(args) {\n  if (args.length === 0 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 3\" means that user sent parameter privateKey or callback\n\n\n  var tx = args[0];\n  var feePayer = args[1];\n  var privateKey;\n  var callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (!utils.isAddress(feePayer)) {\n    throw new Error(\"Invalid fee payer address : \".concat(feePayer));\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      privateKey = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    feePayer,\n    callback\n  };\n}\n/**\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\n *\n * @method resolveArgsForSignTransactionWithHash\n * @param {Object} args Parameters of signTransactionWithHash.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransactionWithHash(args) {\n  if (args.length < 2 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  }\n\n  var hash = args[0];\n  var privateKeys = args[1];\n  var chainId;\n  var callback;\n\n  if (!hash) {\n    throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.');\n  }\n\n  if (!utils.isTxHashStrict(hash)) {\n    throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.');\n  }\n\n  if (!privateKeys || !Array.isArray(privateKeys) && !_.isString(privateKeys)) {\n    throw new Error(\"Invalid parameter: The private key should be a private key string or an array of private keys.\");\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      chainId = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the chain id is invalid.');\n    }\n\n    chainId = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    hash,\n    privateKeys,\n    chainId,\n    callback\n  };\n}\n\nfunction encryptKey(privateKey, password, options) {\n  var encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  var privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (var i = 0; i < privateKeyArray.length; i++) {\n    var salt = options.salt || cryp.randomBytes(32);\n    var iv = options.iv || cryp.randomBytes(16);\n    var derivedKey = void 0;\n    var kdf = options.kdf || 'scrypt';\n    var kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt - default\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    var ciphertext = Buffer.concat([cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), cipher.final()]);\n    var mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')])).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n}\n\nvar Accounts = function Accounts(...args) {\n  var _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, args); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  var _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]; // attach methods to this._klaytnCall\n\n  this._klaytnCall = {};\n\n  _.each(_klaytnCall, function (method) {\n    method = new Method(method);\n    method.attachToObject(_this._klaytnCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  var _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    var roleKey = _this._getRoleKey(tx, account);\n\n    return _this.signTransaction(tx, roleKey, callback);\n  };\n\n  account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n    return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account.privateKey);\n  };\n\n  account.encrypt = function encrypt(password, options = {}) {\n    options.address = account.address;\n    return _this.encrypt(account.keys, password, options);\n  };\n\n  account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n    return genKlaytnWalletKeyStringFromAccount(account);\n  };\n\n  return account;\n};\n/**\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\n *\n * @method _determineAddress\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\n * @param {String} addressFromKey Address extracted from key.\n * @param {String} userInputAddress Address passed as parameter by user.\n * @return {String}\n */\n\n\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n  if (userInputAddress) {\n    if (addressFromKey && addressFromKey !== userInputAddress) {\n      throw new Error('The address extracted from the private key does not match the address received as the input value.');\n    }\n\n    if (!utils.isAddress(userInputAddress)) {\n      throw new Error('The address received as the input value is invalid.');\n    }\n\n    return userInputAddress;\n  }\n\n  if (addressFromKey) {\n    if (!utils.isAddress(addressFromKey)) {\n      throw new Error('The address extracted from the private key is invalid.');\n    } // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n\n\n    return addressFromKey;\n  }\n\n  return legacyAccount.address;\n};\n/**\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\n *\n * @method _getRoleKey\n * @param {Object} tx transaction object to be sign.\n * @param {Object} account Account to be used for signing.\n * @return {String|Array}\n */\n\n\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n  var key;\n\n  if (!account) {\n    throw new Error('The account to be used for signing is not defined.');\n  }\n\n  if (tx.senderRawTransaction && tx.feePayer) {\n    key = account.feePayerKey;\n  } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n    key = account.updateKey;\n  } else {\n    key = account.transactionKey;\n  }\n\n  if (!key) {\n    throw new Error('The key corresponding to the role used for signing is not defined.');\n  }\n\n  return key;\n};\n/**\n * create function creates random account with entropy.\n *\n * @method create\n * @param {Object} entropy A random string to increase entropy.\n * @return {Object}\n */\n\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))));\n};\n/**\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\n *\n * @method createAccountKey\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n  if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys;\n\n  if (_.isString(accountKey)) {\n    accountKey = this.createAccountKeyPublic(accountKey);\n  } else if (_.isArray(accountKey)) {\n    accountKey = this.createAccountKeyMultiSig(accountKey);\n  } else if (_.isObject(accountKey)) {\n    accountKey = this.createAccountKeyRoleBased(accountKey);\n  } else {\n    throw new Error(\"Invalid accountKey type: \".concat(typeof accountKey));\n  }\n\n  return accountKey;\n};\n/**\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\n *\n * @method createAccountKeyPublic\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n  if (privateKey instanceof AccountKeyPublic) return privateKey;\n\n  if (!_.isString(privateKey)) {\n    throw new Error('Creating a AccountKeyPublic requires a private key string.');\n  }\n\n  var parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error(\"Failed to create AccountKeyPublic. Invalid private key : \".concat(privateKey));\n  }\n\n  return new AccountKeyPublic(privateKey);\n};\n/**\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\n *\n * @method createAccountKeyMultiSig\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n  if (privateKeys instanceof AccountKeyMultiSig) return privateKeys;\n\n  if (!_.isArray(privateKeys)) {\n    throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.');\n  }\n\n  for (var i = 0; i < privateKeys.length; i++) {\n    var parsed = utils.parsePrivateKey(privateKeys[i]);\n    var p = parsed.privateKey;\n\n    if (!utils.isValidPrivateKey(p)) {\n      throw new Error(\"Failed to create AccountKeyMultiSig. Invalid private key : \".concat(p));\n    }\n  }\n\n  return new AccountKeyMultiSig(privateKeys);\n};\n/**\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\n *\n * @method createAccountKeyRoleBased\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n  if (keyObject instanceof AccountKeyRoleBased) return keyObject;\n\n  if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n    throw new Error('Creating a AccountKeyRoleBased requires an object.');\n  }\n\n  return new AccountKeyRoleBased(keyObject);\n};\n/**\n * accountKeyToPublicKey creates public key format with AccountKey.\n *\n * @method accountKeyToPublicKey\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\n * @return {String|Array|Object}\n */\n\n\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n  accountKey = this.createAccountKey(accountKey);\n  return accountKey.toPublicKey(this.privateKeyToPublicKey);\n};\n/**\n * createWithAccountKey creates Account instance with AccountKey.\n *\n * @method createWithAccountKey\n * @param {String} address The address of account.\n * @param {String|Array|Object} accountKey The accountKey of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n  var account = new Account(address, this.createAccountKey(accountKey));\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\n *\n * @method createWithAccountKeyPublic\n * @param {String} address An address of account.\n * @param {String|Object} key Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n  if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key);\n\n  if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error(\"Failed to create account with AccountKeyPublic. Invalid account key : \".concat(key.type));\n  }\n\n  var account = new Account(address, key);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\n *\n * @method createWithAccountKeyMultiSig\n * @param {String} address An address of account.\n * @param {String|Object} keys Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n  if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys);\n\n  if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n    throw new Error(\"Failed to create account with AccountKeyMultiSig. Invalid account key : \".concat(keys.type));\n  }\n\n  var account = new Account(address, keys);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\n *\n * @method createWithAccountKeyRoleBased\n * @param {String} address An address of account.\n * @param {String|Object} keyObject Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n  if (!Account.isAccountKey(keyObject)) {\n    keyObject = this.createAccountKeyRoleBased(keyObject);\n  }\n\n  if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n    throw new Error(\"Failed to create account with AccountKeyRoleBased. Invalid account key : \".concat(keyObject.type));\n  }\n\n  var account = new Account(address, keyObject);\n  return this._addAccountFunctions(account);\n};\n/**\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\n *\n * @method privateKeyToAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n  var _this$getLegacyAccoun = this.getLegacyAccount(key),\n      account = _this$getLegacyAccoun.legacyAccount,\n      klaytnWalletKeyAddress = _this$getLegacyAccoun.klaytnWalletKeyAddress;\n\n  account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress);\n  account.address = account.address.toLowerCase();\n  account.address = utils.addHexPrefix(account.address);\n  return account;\n};\n/**\n * createAccountForUpdate creates an AccountForUpdate instance.\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\n *\n * @method createAccountForUpdate\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n  var legacyOrFail; // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n\n  if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n    legacyOrFail = {};\n    Object.keys(accountKey).map(role => {\n      if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n        legacyOrFail[role] = accountKey[role];\n        delete accountKey[role];\n      }\n    });\n\n    if (Object.keys(accountKey).length === 0) {\n      return new AccountForUpdate(address, legacyOrFail, options);\n    }\n  }\n\n  var publicKey = this.accountKeyToPublicKey(accountKey);\n\n  if (legacyOrFail !== undefined) {\n    Object.assign(publicKey, legacyOrFail);\n  }\n\n  return new AccountForUpdate(address, publicKey, options);\n};\n/**\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\n *\n * @method createAccountForUpdateWithPublicKey\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} keyForUpdate Public key to update.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n  return new AccountForUpdate(address, keyForUpdate, options);\n};\n/**\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\n *\n * @method createAccountForUpdateWithLegacyKey\n * @param {String} address The address of account to update with the legacy key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n  return new AccountForUpdate(address, 'legacyKey');\n};\n/**\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\n *\n * @method createAccountForUpdateWithFailKey\n * @param {String} address The address of account to update with the fail key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n  return new AccountForUpdate(address, 'failKey');\n};\n/**\n * isDecoupled determines whether or not it is decoupled based on the input value.\n *\n * @method isDecoupled\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\n * @return {Boolean}\n */\n\n\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n  var _this$getLegacyAccoun2 = this.getLegacyAccount(key),\n      legacyAccount = _this$getLegacyAccoun2.legacyAccount,\n      klaytnWalletKeyAddress = _this$getLegacyAccoun2.klaytnWalletKeyAddress;\n\n  var actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress);\n\n  return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase();\n};\n/**\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\n *\n * @method getLegacyAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @return {Object}\n */\n\n\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n  var parsed = utils.parsePrivateKey(key);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  var privateKey = utils.addHexPrefix(parsed.privateKey);\n\n  var account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)));\n\n  return {\n    legacyAccount: account,\n    klaytnWalletKeyAddress: parsed.address\n  };\n};\n/**\n * signTransaction signs to transaction with private key.\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\n *\n * @method signTransaction\n * @param {String|Object} tx The transaction to sign.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransaction = function signTransaction() {\n  var _this = this;\n\n  var isLegacy = false;\n  var isFeePayer = false;\n  var existedSenderSignatures = [];\n  var existedFeePayerSignatures = [];\n  var result;\n  var tx;\n  var privateKey;\n  var callback;\n\n  var handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    var resolved = resolveArgsForSignTransaction(arguments);\n    tx = resolved.tx;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  } // If the user signs an RLP encoded transaction, tx is of type string.\n\n\n  if (_.isString(tx)) {\n    tx = decodeFromRawTransaction(tx);\n  } // Validate tx object\n\n\n  var error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    if (tx.feePayerSignatures) {\n      existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures);\n    }\n\n    try {\n      // Decode senderRawTransaction to get signatures of fee payer\n      var _splitFeePayer = splitFeePayer(tx.senderRawTransaction),\n          senderRawTransaction = _splitFeePayer.senderRawTransaction,\n          feePayer = _splitFeePayer.feePayer,\n          feePayerSignatures = _splitFeePayer.feePayerSignatures; // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n\n      if (feePayer !== '0x') {\n        // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n        if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n          return handleError(\"Invalid feePayer: The fee payer(\".concat(feePayer, \") included in the transaction does not match the fee payer(\").concat(tx.feePayer, \") you want to sign.\"));\n        }\n\n        existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures);\n      }\n\n      tx.senderRawTransaction = senderRawTransaction;\n      isFeePayer = true;\n    } catch (e) {\n      return handleError(e);\n    }\n  } else {\n    isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY');\n\n    if (tx.signatures) {\n      // if there is existed signatures or feePayerSignatures, those should be preserved.\n      if (isLegacy) {\n        return handleError('Legacy transaction cannot be signed with multiple keys.');\n      }\n\n      existedSenderSignatures = existedSenderSignatures.concat(tx.signatures);\n    }\n  } // When privateKey is undefined, find Account from Wallet.\n\n\n  if (privateKey === undefined) {\n    try {\n      var account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from);\n\n      if (!account) {\n        return handleError('Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.');\n      }\n\n      privateKey = this._getRoleKey(tx, account);\n    } catch (e) {\n      return handleError(e);\n    }\n  }\n\n  var privateKeys = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  try {\n    for (var i = 0; i < privateKeys.length; i++) {\n      var parsed = utils.parsePrivateKey(privateKeys[i]);\n      privateKeys[i] = parsed.privateKey;\n      privateKeys[i] = utils.addHexPrefix(privateKeys[i]);\n\n      if (!utils.isValidPrivateKey(privateKeys[i])) {\n        return handleError('Invalid private key');\n      }\n    }\n  } catch (e) {\n    return handleError(e);\n  } // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n\n\n  if (isLegacy) {\n    if (privateKeys.length > 1) {\n      return handleError('Legacy transaction cannot signed with multiple keys');\n    }\n\n    if (_this.isDecoupled(privateKeys[0], tx.from)) {\n      return handleError('A legacy transaction must be with a legacy account key');\n    }\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      var transaction = coverInitialTxValue(txObject);\n      var rlpEncoded = encodeRLPByTxType(transaction);\n      var messageHash = Hash.keccak256(rlpEncoded);\n      var sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures;\n\n      var _iterator = _createForOfIteratorHelper(privateKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          var signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p);\n\n          var _AccountLib$decodeSig = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n              _AccountLib$decodeSig2 = _slicedToArray(_AccountLib$decodeSig, 3),\n              v = _AccountLib$decodeSig2[0],\n              r = _AccountLib$decodeSig2[1],\n              s = _AccountLib$decodeSig2[2];\n\n          sigs.push([v, r, s]);\n        } // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _makeRawTransaction = makeRawTransaction(rlpEncoded, sigs, transaction),\n          rawTransaction = _makeRawTransaction.rawTransaction,\n          signatures = _makeRawTransaction.signatures,\n          _feePayerSignatures = _makeRawTransaction.feePayerSignatures;\n\n      result = {\n        messageHash,\n        v: sigs[0][0],\n        r: sigs[0][1],\n        s: sigs[0][2],\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (isFeePayer) {\n        result.feePayerSignatures = _feePayerSignatures;\n      } else {\n        result.signatures = signatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // When the feePayer signs a transaction, required information is only chainId.\n\n\n  if (isFeePayer) {\n    return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function (args) {\n      if (isNot(args[0])) {\n        throw new Error(\"\\\"chainId\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n      }\n\n      return signed(_.extend(tx, {\n        chainId: args[0]\n      }));\n    });\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\n *\n * @method feePayerSignTransaction\n * @param {Object|String} tx The transaction to sign.\n * @param {String} feePayer The address of fee payer.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n  var _this = this;\n\n  var tx;\n  var feePayer;\n  var privateKey;\n  var callback;\n\n  var handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    var resolved = resolveArgsForFeePayerSignTransaction(arguments);\n    tx = resolved.tx;\n    feePayer = resolved.feePayer;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  if (_.isString(tx)) {\n    return this.signTransaction({\n      senderRawTransaction: tx,\n      feePayer\n    }, privateKey, callback);\n  }\n\n  if (!tx.feePayer || tx.feePayer === '0x') {\n    tx.feePayer = feePayer;\n  }\n\n  if (!tx.senderRawTransaction) {\n    if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n      return handleError(\"Failed to sign transaction with fee payer: invalid transaction type(\".concat(tx.type ? tx.type : 'LEGACY', \")\"));\n    }\n  }\n\n  var e = helpers.validateFunction.validateParams(tx);\n\n  if (e) {\n    return handleError(e);\n  }\n\n  if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n    return handleError('Invalid parameter: The address of fee payer does not match.');\n  }\n\n  if (tx.senderRawTransaction) {\n    return this.signTransaction(tx, privateKey, callback);\n  }\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    var chainId = args[0];\n    var gasPrice = args[1];\n    var nonce = args[2];\n\n    if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    var transaction = _.extend(tx, {\n      chainId,\n      gasPrice,\n      nonce\n    });\n\n    transaction = helpers.formatters.inputCallFormatter(transaction);\n    transaction = coverInitialTxValue(transaction);\n    var rlpEncoded = encodeRLPByTxType(transaction);\n    var sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']];\n\n    var _makeRawTransaction2 = makeRawTransaction(rlpEncoded, sig, transaction),\n        rawTransaction = _makeRawTransaction2.rawTransaction;\n\n    return _this.signTransaction({\n      senderRawTransaction: rawTransaction,\n      feePayer,\n      chainId\n    }, privateKey, callback);\n  });\n};\n/**\n * signTransactionWithHash signs to transaction hash with private key(s).\n *\n * @method signTransactionWithHash\n * @param {String} hash The hash of transaction to sign.\n * @param {String|Array} privateKeys The private key(s) to use for signing.\n * @param {String|Number} chainId The chain id of the network.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n  var _this = this;\n\n  var hash;\n  var privateKeys;\n  var chainId;\n  var callback;\n\n  var handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    var resolved = resolveArgsForSignTransactionWithHash(arguments);\n    hash = resolved.hash;\n    chainId = resolved.chainId;\n    privateKeys = resolved.privateKeys;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys];\n\n  function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n    var result = [];\n    chain = utils.numberToHex(chain);\n\n    try {\n      var _iterator2 = _createForOfIteratorHelper(prvKeys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var privateKey = _step2.value;\n          var p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey);\n\n          if (!utils.isValidPrivateKey(p)) {\n            return handleError(\"Failed to sign transaction with hash: Invalid private key \".concat(privateKey));\n          }\n\n          var signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p);\n\n          var _AccountLib$decodeSig3 = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n              _AccountLib$decodeSig4 = _slicedToArray(_AccountLib$decodeSig3, 3),\n              v = _AccountLib$decodeSig4[0],\n              r = _AccountLib$decodeSig4[1],\n              s = _AccountLib$decodeSig4[2];\n\n          result.push(utils.transformSignaturesToObject([v, r, s]));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } catch (e) {\n      callbackFunc(e);\n      return Promise.reject(e);\n    }\n\n    callbackFunc(null, result);\n    return result;\n  }\n\n  return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n    return signWithHash(hash, privateKeys, id, callback);\n  });\n};\n/**\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\n *\n * @method getRawTransactionWithSignatures\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n  var _this = this;\n\n  var result;\n\n  callback = callback || function () {};\n\n  var handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!tx || !_.isObject(tx)) {\n    return handleError('Invalid parameter: The transaction must be defined as an object');\n  }\n\n  if (!tx.signatures && !tx.feePayerSignatures) {\n    return handleError('There are no signatures or feePayerSignatures defined in the transaction object.');\n  }\n\n  var error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']];\n    var decoded = decodeFromRawTransaction(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n    if (decoded.feePayer !== '0x' && !utils.isEmptySig(decoded.feePayerSignatures)) {\n      if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n        return handleError('Invalid feePayer');\n      }\n\n      tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures);\n    }\n\n    decoded.feePayer = tx.feePayer;\n    decoded.feePayerSignatures = tx.feePayerSignatures;\n\n    if (tx.signatures) {\n      decoded.signatures = decoded.signatures.concat(tx.signatures);\n    }\n\n    tx = decoded;\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      var transaction = coverInitialTxValue(txObject);\n      var rlpEncoded = encodeRLPByTxType(transaction);\n      var sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x'];\n      if (!_.isArray(sigs[0])) sigs = [sigs];\n\n      var _makeRawTransaction3 = makeRawTransaction(rlpEncoded, sigs, transaction),\n          rawTransaction = _makeRawTransaction3.rawTransaction,\n          signatures = _makeRawTransaction3.signatures,\n          feePayerSignatures = _makeRawTransaction3.feePayerSignatures;\n\n      result = {\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (signatures && !utils.isEmptySig(signatures)) {\n        result.signatures = signatures;\n      }\n\n      if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n        result.feePayerSignatures = feePayerSignatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * combineSignatures combines RLP encoded raw transaction strings.\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\n * The comparison allows that the address of the fee payer is '0x'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\n * In this case, feePayer field doesn't have to be compared with other transaction.\n *\n * @method combineSignatures\n * @param {Array} rawTransactions The array of raw transaction string to combine.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n  var decodedTx;\n  var senders = [];\n  var feePayers = [];\n  var feePayer;\n\n  callback = callback || function () {};\n\n  var handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!_.isArray(rawTransactions)) {\n    return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.');\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(rawTransactions),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var raw = _step3.value;\n\n      var _extractSignatures = extractSignatures(raw),\n          senderSignatures = _extractSignatures.senderSignatures,\n          feePayerSignatures = _extractSignatures.feePayerSignatures,\n          decodedTransaction = _extractSignatures.decodedTransaction;\n\n      senders = senders.concat(senderSignatures);\n      feePayers = feePayers.concat(feePayerSignatures);\n\n      if (decodedTx) {\n        var isSame = true;\n        var keys = Object.keys(decodedTx);\n\n        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n          var key = _keys[_i];\n\n          if (key === 'v' || key === 'r' || key === 's' || key === 'signatures' || key === 'payerV' || key === 'payerR' || key === 'payerS' || key === 'feePayerSignatures') {\n            continue;\n          } // feePayer field can be '0x' when after sender signs to trasnaction.\n          // For handling this, if feePayer is '0x', don't compare with other transaction\n\n\n          if (key === 'feePayer') {\n            if (decodedTransaction[key] === '0x') {\n              continue;\n            } else {\n              // set feePayer letiable with valid feePayer address(not '0x')\n              feePayer = decodedTransaction[key];\n\n              if (decodedTx[key] === '0x') {\n                // set feePayer field to decodedTx for comparing feePayer address with other transactions\n                decodedTx[key] = decodedTransaction[key];\n              }\n            }\n          }\n\n          if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n            isSame = false;\n            break;\n          }\n        }\n\n        if (!isSame) {\n          return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.');\n        }\n      } else {\n        decodedTx = decodedTransaction;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var parsedTxObject = decodeFromRawTransaction(rawTransactions[0]);\n  parsedTxObject.signatures = senders;\n\n  if (feePayer) {\n    parsedTxObject.feePayer = feePayer;\n\n    if (feePayers.length > 0) {\n      parsedTxObject.feePayerSignatures = feePayers;\n    }\n  }\n\n  return this.getRawTransactionWithSignatures(parsedTxObject, callback);\n};\n/**\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n    throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".');\n  }\n\n  var values = RLP.decode(rawTx); // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n\n  var arr = values.slice(7, 9).map(sig => {\n    sig = sig.replace('0x', '');\n\n    while (sig.length < 64) {\n      sig = \"0\".concat(sig);\n    }\n\n    return \"0x\".concat(sig);\n  });\n  arr.unshift(values[6]);\n  var signature = AccountLib.encodeSignature(arr);\n  var recovery = Bytes.toNumber(values[6]);\n  var extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n  var signingData = values.slice(0, 6).concat(extraData);\n  var signingDataHex = RLP.encode(signingData);\n  return AccountLib.recover(Hash.keccak256(signingDataHex), signature);\n};\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  var message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  var messageBuffer = Buffer.from(message);\n  var preamble = \"\\x19Klaytn Signed Message:\\n\".concat(message.length);\n  var preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  var klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\n\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  var parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  var messageHash = this.hashMessage(data);\n  var signature = AccountLib.sign(messageHash, privateKey);\n\n  var _AccountLib$decodeSig5 = AccountLib.decodeSignature(signature),\n      _AccountLib$decodeSig6 = _slicedToArray(_AccountLib$decodeSig5, 3),\n      v = _AccountLib$decodeSig6[0],\n      r = _AccountLib$decodeSig6[1],\n      s = _AccountLib$decodeSig6[2];\n\n  return {\n    message: data,\n    messageHash,\n    v,\n    r,\n    s,\n    signature\n  };\n};\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\n\n\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n  var args = [].slice.apply(arguments);\n\n  if (_.isObject(message)) {\n    return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true);\n  }\n\n  if (!preFixed) {\n    message = this.hashMessage(message);\n  }\n\n  if (args.length >= 4) {\n    preFixed = args.slice(-1)[0];\n    preFixed = _.isBoolean(preFixed) ? !!preFixed : false;\n    return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n  }\n  /**\n   * recover in Account module\n   * const recover = (hash, signature) => {\n   *   const vals = decodeSignature(signature);\n   *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n   *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n   *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\n   *   const publicHash = keccak256(publicKey);\n   *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n   *   return address;\n   * };\n   */\n\n\n  return AccountLib.recover(message, signature);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  if (!_.isString(password)) {\n    throw new Error('No password given.');\n  }\n\n  var json = _.isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n  if (json.version !== 3 && json.version !== 4) {\n    console.warn('This is not a V3 or V4 wallet.'); // throw new Error('Not a valid V3 wallet');\n  }\n\n  if (json.version === 3 && !json.crypto) {\n    // crypto field should be existed in keystore version 3\n    throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n  }\n\n  if (json.crypto) {\n    if (json.keyring) {\n      throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\");\n    }\n\n    json.keyring = [json.crypto];\n    delete json.crypto;\n  }\n\n  if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n    throw new Error('Invalid key store format');\n  }\n\n  var accountKey = {}; // AccountKeyRoleBased format\n\n  if (_.isArray(json.keyring[0])) {\n    var transactionKey = decryptKey(json.keyring[0]);\n    if (transactionKey) accountKey.transactionKey = transactionKey;\n    var updateKey = decryptKey(json.keyring[1]);\n    if (updateKey) accountKey.updateKey = updateKey;\n    var feePayerKey = decryptKey(json.keyring[2]);\n    if (feePayerKey) accountKey.feePayerKey = feePayerKey;\n  } else {\n    accountKey = decryptKey(json.keyring);\n  }\n\n  function decryptKey(encryptedArray) {\n    if (!encryptedArray || encryptedArray.length === 0) return undefined;\n    var decryptedArray = [];\n\n    var _iterator4 = _createForOfIteratorHelper(encryptedArray),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var encrypted = _step4.value;\n        var derivedKey = void 0;\n        var kdfparams = void 0;\n        /**\n         * Supported kdf modules are the following:\n         * 1) pbkdf2\n         * 2) scrypt\n         */\n\n        if (encrypted.kdf === 'scrypt') {\n          kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n          derivedKey = scrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else if (encrypted.kdf === 'pbkdf2') {\n          kdfparams = encrypted.kdfparams;\n\n          if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n          }\n\n          derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n        } else {\n          throw new Error('Unsupported key derivation scheme');\n        }\n\n        var ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n        var mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n        if (mac !== encrypted.mac) {\n          throw new Error('Key derivation failed - possibly wrong password');\n        }\n\n        var decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n        decryptedArray.push(\"0x\".concat(Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex')));\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray;\n  }\n\n  return this.createWithAccountKey(json.address, accountKey);\n};\n/*\n    The fields of kdfparams are described below.\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n */\n\n/**\n * encrypt encrypts an account and returns a key store v4 object.\n *\n * @method encrypt\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encrypt = function (key, password, options) {\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n  options = options || {};\n  var address;\n  var account;\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else {\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  var keyring;\n  var transactionKey;\n  var updateKey;\n  var feePayerKey;\n\n  switch (account.accountKeyType) {\n    case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n    case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n      keyring = encryptKey(account.keys, password, options);\n      break;\n\n    case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n      keyring = [];\n      transactionKey = encryptKey(account.transactionKey, password, options);\n      updateKey = encryptKey(account.updateKey, password, options);\n      feePayerKey = encryptKey(account.feePayerKey, password, options);\n      keyring.push(transactionKey);\n      keyring.push(updateKey);\n      keyring.push(feePayerKey);\n\n      for (var i = keyring.length - 1; i >= 0; i--) {\n        if (keyring[i].length !== 0) break;\n        keyring = keyring.slice(0, i);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"Unsupported account key type: \".concat(account.accountKeyType));\n  }\n\n  return {\n    version: 4,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    keyring\n  };\n};\n/**\n * encryptV3 encrypts an account and returns a key store v3 object.\n *\n * @method encryptV3\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encryptV3 = function (key, password, options) {\n  options = options || {};\n  var address;\n  var account;\n  var notSupportedType = 'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.';\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else if (Account.isAccountKey(key)) {\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  } else {\n    throw new Error(notSupportedType);\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  var crypto = encryptKey(account.keys, password, options);\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    crypto: crypto[0]\n  };\n};\n\nAccounts.prototype.privateKeyToPublicKey = function (privateKey, compressed = false) {\n  var parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 64) {\n    throw new Error('Received a invalid privateKey. The length of privateKey should be 64.');\n  }\n\n  var buffer = Buffer.from(privateKey, 'hex');\n  var ecKey = secp256k1.keyFromPrivate(buffer);\n  var publicKey;\n\n  if (!compressed) {\n    publicKey = \"0x\".concat(ecKey.getPublic(false, 'hex').slice(2));\n  } else {\n    publicKey = \"0x\".concat(ecKey.getPublic(true, 'hex'));\n  }\n\n  return publicKey;\n};\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType;\n\nAccounts.prototype.setAccounts = function (accounts) {\n  this.wallet.clear();\n\n  for (var i = 0; i < accounts.wallet.length; i++) {\n    this.wallet.add(accounts.wallet[i]);\n  }\n\n  return this;\n};\n/* eslint-enable complexity */\n// Note: this is trying to follow closely the specs on\n\n/**\n  > Wallet {\n      0: {...}, // account by index\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n      1: {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n      add: function(){},\n      remove: function(){},\n      save: function(){},\n      load: function(){},\n      clear: function(){},\n\n      length: 2,\n  }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n */\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = 'caverjs_wallet';\n}\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  if (_.has(this, pointer)) {\n    return this._findSafeIndex(pointer + 1);\n  }\n\n  return pointer;\n};\n\nWallet.prototype._currentIndexes = function () {\n  var keys = Object.keys(this);\n  var indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (var i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n */\n\n\nWallet.prototype.add = function (account, userInputAddress) {\n  var accountForWallet;\n  /**\n   * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n   *\n   * cav.klay.accounts.wallet.add({\n   *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n   *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n   * });\n   */\n\n  if (Account.isAccountKey(account)) {\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account);\n  } else if (account instanceof Account) {\n    accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey);\n    accountForWallet.address = userInputAddress || account.address;\n  } else if (_.isObject(account) && account.address && account.privateKey) {\n    accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address);\n  } else if (_.isString(account)) {\n    accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress);\n  } else {\n    var accountKey = this._accounts.createAccountKey(account);\n\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey format');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey);\n  }\n\n  if (this[accountForWallet.address]) {\n    throw new Error(\"Account exists with \".concat(accountForWallet.address));\n  }\n\n  accountForWallet.index = this._findSafeIndex();\n  this[accountForWallet.index] = accountForWallet;\n  this[accountForWallet.address] = accountForWallet;\n  this[accountForWallet.address.toLowerCase()] = accountForWallet;\n  this[accountForWallet.address.toUpperCase()] = accountForWallet;\n\n  try {\n    this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet;\n  } catch (e) {}\n\n  this.length++;\n  return accountForWallet;\n};\n\nWallet.prototype.updatePrivateKey = function (privateKey, address) {\n  if (privateKey === undefined || address === undefined) {\n    throw new Error('To update the privatKey in wallet, need to set both privateKey and address.');\n  } // If privateKey parameter is not string type, return error\n\n\n  if (!_.isString(privateKey)) {\n    throw new Error('The private key used for the update is not a valid string.');\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(\"Invalid address : \".concat(address));\n  } // If failed to find account through address, return error\n\n\n  var accountExists = !!this[address];\n  if (!accountExists) throw new Error(\"Failed to find account with \".concat(address));\n  var account = this[address];\n\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.');\n  }\n\n  var parsed = utils.parsePrivateKey(privateKey);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  if (parsed.address && parsed.address !== account.address) {\n    throw new Error('The address extracted from the private key does not match the address received as the input value.');\n  }\n\n  var newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey);\n  this[account.index].accountKey = newAccountKeyPublic;\n  this[account.address].accountKey = newAccountKeyPublic;\n  this[account.address.toLowerCase()].accountKey = newAccountKeyPublic;\n  this[account.address.toUpperCase()].accountKey = newAccountKeyPublic;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n  if (address === undefined || accountKey === undefined) {\n    throw new Error('To update the accountKey in wallet, need to set both address and accountKey.');\n  }\n\n  if (!Account.isAccountKey(accountKey)) {\n    accountKey = this._accounts.createAccountKey(accountKey);\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(\"Invalid address : \".concat(address));\n  } // If failed to find account through address, return error\n\n\n  var accountExists = !!this[address];\n  if (!accountExists) throw new Error(\"Failed to find account with \".concat(address));\n  var account = this[address];\n  this[account.index].accountKey = accountKey;\n  this[account.address].accountKey = accountKey;\n  this[account.address.toLowerCase()].accountKey = accountKey;\n  this[account.address.toUpperCase()].accountKey = accountKey;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = accountKey;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.remove = function (addressOrIndex) {\n  var account = this[addressOrIndex];\n\n  if (account && account.address) {\n    // address\n    this[account.address].accountKey = null;\n    delete this[account.address];\n\n    if (this[account.address.toLowerCase()]) {\n      // address lowercase\n      this[account.address.toLowerCase()].accountKey = null;\n      delete this[account.address.toLowerCase()];\n    }\n\n    if (this[account.address.toUpperCase()]) {\n      // address uppercase\n      this[account.address.toUpperCase()].accountKey = null;\n      delete this[account.address.toUpperCase()];\n    }\n\n    try {\n      this[utils.toChecksumAddress(account.address)].accountKey = null;\n      delete this[utils.toChecksumAddress(account.address)];\n    } catch (e) {} // index\n\n\n    this[account.index].accountKey = null;\n    delete this[account.index];\n    this.length--;\n    return true;\n  }\n\n  return false;\n};\n\nWallet.prototype.clear = function () {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n/**\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\n\n\nWallet.prototype.encrypt = function (password, options) {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  var accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n/**\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\n\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  var _this = this;\n\n  encryptedWallet.forEach(function (keystore) {\n    var account = _this._accounts.decrypt(keystore, password);\n\n    if (!account) {\n      throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\");\n    }\n\n    var exist = !!_this[account.address];\n\n    if (!exist) {\n      _this.add(account);\n    }\n  });\n  return this;\n};\n\nWallet.prototype.save = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n/**\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\n\n\nWallet.prototype.load = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  var keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n\nif (typeof localStorage === 'undefined') {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n\nWallet.prototype.getKlaytnWalletKey = function (addressOrIndex) {\n  var account = this[addressOrIndex];\n  if (!account) throw new Error('Failed to find account');\n  return genKlaytnWalletKeyStringFromAccount(account);\n};\n\nWallet.prototype.getAccount = function (input) {\n  if (_.isNumber(input)) {\n    if (this.length <= input) {\n      throw new Error(\"The index(\".concat(input, \") is out of range(Wallet length : \").concat(this.length, \").\"));\n    }\n\n    return this[input];\n  }\n\n  if (!_.isString(input)) {\n    throw new Error(\"Accounts in the Wallet can be searched by only index or address. :\".concat(input));\n  }\n\n  if (!utils.isAddress(input)) {\n    throw new Error(\"Failed to getAccount from Wallet: invalid address(\".concat(input, \")\"));\n  }\n\n  return this[input.toLowerCase()];\n};\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.');\n  }\n\n  var addressString = account.address;\n  var privateKey = account.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : \"0x\".concat(privateKey);\n  addressString = addressString.slice(0, 2) === '0x' ? addressString : \"0x\".concat(addressString);\n  return \"\".concat(privateKey, \"0x00\").concat(addressString);\n}\n\nmodule.exports = Accounts;","map":{"version":3,"sources":["C:/Users/MONK/Desktop/Cryptoberry(db)/client/node_modules/caver-js/packages/caver-klay/caver-klay-accounts/src/index.js"],"names":["_","require","Promise","AccountLib","Hash","RLP","Nat","Bytes","cryp","global","uuid","elliptic","scrypt","utils","helpers","Method","core","encodeRLPByTxType","makeRawTransaction","getSenderTxHash","decodeFromRawTransaction","splitFeePayer","extractSignatures","secp256k1","ec","AccountKeyPublic","AccountKeyMultiSig","AccountKeyRoleBased","AccountKeyEnum","Account","AccountForUpdate","rpc","isNot","value","isUndefined","isNull","coverInitialTxValue","tx","Error","senderRawTransaction","type","includes","to","data","addHexPrefix","chainId","numberToHex","resolveArgsForSignTransaction","args","length","privateKey","callback","isObject","isString","isFunction","isArray","resolveArgsForFeePayerSignTransaction","feePayer","isAddress","resolveArgsForSignTransactionWithHash","hash","privateKeys","isTxHashStrict","Array","isNumber","encryptKey","password","options","encryptedArray","privateKeyArray","i","salt","randomBytes","iv","derivedKey","kdf","kdfparams","dklen","toString","c","prf","pbkdf2Sync","Buffer","from","n","r","p","cipher","createCipheriv","slice","ciphertext","concat","update","replace","final","mac","sha3","push","cipherparams","Accounts","_this","packageInit","BatchRequest","extend","_klaytnCall","getChainId","getGasPrice","getTransactionCount","each","method","attachToObject","setRequestManager","_requestManager","wallet","Wallet","prototype","_addAccountFunctions","account","signTransaction","roleKey","_getRoleKey","feePayerSignTransaction","address","feePayerKey","sign","encrypt","keys","getKlaytnWalletKey","genKlaytnWalletKeyStringFromAccount","_determineAddress","legacyAccount","addressFromKey","userInputAddress","key","updateKey","transactionKey","create","entropy","fromObject","randomHex","createAccountKey","accountKey","isAccountKey","createAccountKeyPublic","createAccountKeyMultiSig","createAccountKeyRoleBased","parsed","parsePrivateKey","isValidPrivateKey","keyObject","accountKeyToPublicKey","toPublicKey","privateKeyToPublicKey","createWithAccountKey","createWithAccountKeyPublic","ACCOUNT_KEY_PUBLIC","createWithAccountKeyMultiSig","ACCOUNT_KEY_MULTISIG","createWithAccountKeyRoleBased","ACCOUNT_KEY_ROLEBASED","privateKeyToAccount","getLegacyAccount","klaytnWalletKeyAddress","toLowerCase","createAccountForUpdate","legacyOrFail","Object","map","role","publicKey","undefined","assign","createAccountForUpdateWithPublicKey","keyForUpdate","createAccountForUpdateWithLegacyKey","createAccountForUpdateWithFailKey","isDecoupled","actualAddress","fromPrivate","isLegacy","isFeePayer","existedSenderSignatures","existedFeePayerSignatures","result","handleError","e","reject","resolved","arguments","error","validateFunction","validateParams","feePayerSignatures","signatures","getAccount","signed","txObject","formatters","inputCallFormatter","transaction","rlpEncoded","messageHash","keccak256","sigs","signature","makeSigner","toNumber","decodeSignature","sig","makeEven","trimLeadingZero","v","s","rawTransaction","txHash","senderTxHash","nonce","gasPrice","resolve","all","then","JSON","stringify","signTransactionWithHash","signWithHash","transactionHash","prvKeys","chain","callbackFunc","transformSignaturesToObject","id","getRawTransactionWithSignatures","decoded","isEmptySig","combineSignatures","rawTransactions","decodedTx","senders","feePayers","raw","senderSignatures","decodedTransaction","isSame","parsedTxObject","recoverTransaction","rawTx","getTxTypeStringFromRawTransaction","values","decode","arr","unshift","encodeSignature","recovery","extraData","fromNumber","signingData","signingDataHex","encode","recover","hashMessage","message","isHexStrict","hexToBytes","messageBuffer","preamble","preambleBuffer","klayMessage","preFixed","apply","isBoolean","decrypt","v3Keystore","nonStrict","json","parse","version","console","warn","crypto","keyring","decryptKey","decryptedArray","encrypted","decipher","createDecipheriv","accountKeyType","v4","random","encryptV3","notSupportedType","compressed","buffer","ecKey","keyFromPrivate","getPublic","setAccounts","accounts","clear","add","_accounts","defaultKeyName","_findSafeIndex","pointer","has","_currentIndexes","indexes","parseInt","filter","numberOfAccounts","accountForWallet","index","toUpperCase","toChecksumAddress","updatePrivateKey","accountExists","newAccountKeyPublic","updateAccountKey","remove","addressOrIndex","forEach","encryptedWallet","keystore","exist","save","keyName","localStorage","setItem","load","getItem","input","addressString","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst Promise = require('any-promise')\n// account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\nconst AccountLib = require('eth-lib/lib/account')\nconst Hash = require('eth-lib/lib/hash')\nconst RLP = require('eth-lib/lib/rlp')\nconst Nat = require('eth-lib/lib/nat')\nconst Bytes = require('eth-lib/lib/bytes')\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto')\nconst uuid = require('uuid')\nconst elliptic = require('elliptic')\nconst scrypt = require('scrypt-shim')\nconst utils = require('../../../caver-utils')\nconst helpers = require('../../../caver-core-helpers')\n\nconst Method = require('../../../caver-core-method')\nconst core = require('../../../caver-core')\nconst {\n    encodeRLPByTxType,\n    makeRawTransaction,\n    getSenderTxHash,\n    decodeFromRawTransaction,\n    splitFeePayer,\n    extractSignatures,\n} = require('./makeRawTransaction')\n\nconst secp256k1 = new elliptic.ec('secp256k1')\n\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic')\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig')\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased')\nconst { AccountKeyEnum } = require('./accountKey/accountKeyEnum')\n\nconst Account = require('./account/account')\nconst AccountForUpdate = require('./account/accountForUpdate')\n\nconst { rpc } = require('../../../caver-rtm')\n\nconst isNot = function(value) {\n    return _.isUndefined(value) || _.isNull(value)\n}\n\nfunction coverInitialTxValue(tx) {\n    if (typeof tx !== 'object') throw new Error('Invalid transaction')\n    if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n        tx.to = tx.to || '0x'\n        tx.data = utils.addHexPrefix(tx.data || '0x')\n    }\n    tx.chainId = utils.numberToHex(tx.chainId)\n    return tx\n}\n\n/**\n * resolveArgsForSignTransaction parse arguments for signTransaction.\n *\n * @method resolveArgsForSignTransaction\n * @param {Object} args Parameters of signTransaction.\n * @return {Object}\n */\nfunction resolveArgsForSignTransaction(args) {\n    if (args.length === 0 || args.length > 3) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    // privateKey and callback are optional parameter\n    // \"args.length === 2\" means that user sent parameter privateKey or callback\n    const tx = args[0]\n    let privateKey\n    let callback\n\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\n    }\n\n    if (args.length === 2) {\n        if (_.isFunction(args[1])) {\n            callback = args[1]\n        } else {\n            privateKey = args[1]\n        }\n    } else if (args.length === 3) {\n        if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\n        }\n        privateKey = args[1]\n        callback = args[2]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { tx, privateKey, callback }\n}\n\n/**\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\n *\n * @method resolveArgsForFeePayerSignTransaction\n * @param {Object} args Parameters of feePayerSignTransaction.\n * @return {Object}\n */\nfunction resolveArgsForFeePayerSignTransaction(args) {\n    if (args.length === 0 || args.length > 4) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    // privateKey and callback are optional parameter\n    // \"args.length === 3\" means that user sent parameter privateKey or callback\n    const tx = args[0]\n    const feePayer = args[1]\n    let privateKey\n    let callback\n\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\n    }\n\n    if (!utils.isAddress(feePayer)) {\n        throw new Error(`Invalid fee payer address : ${feePayer}`)\n    }\n\n    if (args.length === 3) {\n        if (_.isFunction(args[2])) {\n            callback = args[2]\n        } else {\n            privateKey = args[2]\n        }\n    } else if (args.length === 4) {\n        if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\n        }\n        privateKey = args[2]\n        callback = args[3]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { tx, privateKey, feePayer, callback }\n}\n\n/**\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\n *\n * @method resolveArgsForSignTransactionWithHash\n * @param {Object} args Parameters of signTransactionWithHash.\n * @return {Object}\n */\nfunction resolveArgsForSignTransactionWithHash(args) {\n    if (args.length < 2 || args.length > 4) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    const hash = args[0]\n    const privateKeys = args[1]\n    let chainId\n    let callback\n\n    if (!hash) {\n        throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.')\n    }\n\n    if (!utils.isTxHashStrict(hash)) {\n        throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.')\n    }\n\n    if (!privateKeys || (!Array.isArray(privateKeys) && !_.isString(privateKeys))) {\n        throw new Error(`Invalid parameter: The private key should be a private key string or an array of private keys.`)\n    }\n\n    if (args.length === 3) {\n        if (_.isFunction(args[2])) {\n            callback = args[2]\n        } else {\n            chainId = args[2]\n        }\n    } else if (args.length === 4) {\n        if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n            throw new Error('Invalid parameter: The parameter for the chain id is invalid.')\n        }\n        chainId = args[2]\n        callback = args[3]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { hash, privateKeys, chainId, callback }\n}\n\nfunction encryptKey(privateKey, password, options) {\n    const encryptedArray = []\n\n    if (!privateKey) return encryptedArray\n\n    const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey]\n\n    for (let i = 0; i < privateKeyArray.length; i++) {\n        const salt = options.salt || cryp.randomBytes(32)\n        const iv = options.iv || cryp.randomBytes(16)\n\n        let derivedKey\n        const kdf = options.kdf || 'scrypt'\n        const kdfparams = {\n            dklen: options.dklen || 32,\n            salt: salt.toString('hex'),\n        }\n\n        /**\n         * Supported kdf modules are the following:\n         * 1) pbkdf2\n         * 2) scrypt - default\n         */\n        if (kdf === 'pbkdf2') {\n            kdfparams.c = options.c || 262144\n            kdfparams.prf = 'hmac-sha256'\n            derivedKey = cryp.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256')\n        } else if (kdf === 'scrypt') {\n            // FIXME: support progress reporting callback\n            kdfparams.n = options.n || 4096 // 2048 4096 8192 16384\n            kdfparams.r = options.r || 8\n            kdfparams.p = options.p || 1\n            derivedKey = scrypt(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen)\n        } else {\n            throw new Error('Unsupported kdf')\n        }\n\n        const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv)\n        if (!cipher) {\n            throw new Error('Unsupported cipher')\n        }\n\n        const ciphertext = Buffer.concat([cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), cipher.final()])\n\n        const mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')])).replace('0x', '')\n\n        encryptedArray.push({\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n                iv: iv.toString('hex'),\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf,\n            kdfparams,\n            mac: mac.toString('hex'),\n        })\n    }\n\n    return encryptedArray\n}\n\nconst Accounts = function Accounts(...args) {\n    const _this = this\n\n    // sets _requestmanager\n    core.packageInit(this, args)\n\n    // remove unecessary core functions\n    delete this.BatchRequest\n    delete this.extend\n\n    const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]\n    // attach methods to this._klaytnCall\n    this._klaytnCall = {}\n    _.each(_klaytnCall, function(method) {\n        method = new Method(method)\n        method.attachToObject(_this._klaytnCall)\n        method.setRequestManager(_this._requestManager)\n    })\n\n    this.wallet = new Wallet(this)\n}\n\nAccounts.prototype._addAccountFunctions = function(account) {\n    const _this = this\n\n    // add sign functions\n    account.signTransaction = function signTransaction(tx, callback) {\n        const roleKey = _this._getRoleKey(tx, account)\n        return _this.signTransaction(tx, roleKey, callback)\n    }\n\n    account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n        return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback)\n    }\n\n    account.sign = function sign(data) {\n        return _this.sign(data, account.privateKey)\n    }\n\n    account.encrypt = function encrypt(password, options = {}) {\n        options.address = account.address\n        return _this.encrypt(account.keys, password, options)\n    }\n\n    account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n        return genKlaytnWalletKeyStringFromAccount(account)\n    }\n\n    return account\n}\n\n/**\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\n *\n * @method _determineAddress\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\n * @param {String} addressFromKey Address extracted from key.\n * @param {String} userInputAddress Address passed as parameter by user.\n * @return {String}\n */\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n    if (userInputAddress) {\n        if (addressFromKey && addressFromKey !== userInputAddress) {\n            throw new Error('The address extracted from the private key does not match the address received as the input value.')\n        }\n\n        if (!utils.isAddress(userInputAddress)) {\n            throw new Error('The address received as the input value is invalid.')\n        }\n        return userInputAddress\n    }\n    if (addressFromKey) {\n        if (!utils.isAddress(addressFromKey)) {\n            throw new Error('The address extracted from the private key is invalid.')\n        }\n        // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n        return addressFromKey\n    }\n    return legacyAccount.address\n}\n\n/**\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\n *\n * @method _getRoleKey\n * @param {Object} tx transaction object to be sign.\n * @param {Object} account Account to be used for signing.\n * @return {String|Array}\n */\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n    let key\n\n    if (!account) {\n        throw new Error('The account to be used for signing is not defined.')\n    }\n\n    if (tx.senderRawTransaction && tx.feePayer) {\n        key = account.feePayerKey\n    } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n        key = account.updateKey\n    } else {\n        key = account.transactionKey\n    }\n\n    if (!key) {\n        throw new Error('The key corresponding to the role used for signing is not defined.')\n    }\n\n    return key\n}\n\n/**\n * create function creates random account with entropy.\n *\n * @method create\n * @param {Object} entropy A random string to increase entropy.\n * @return {Object}\n */\nAccounts.prototype.create = function create(entropy) {\n    return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))))\n}\n\n/**\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\n *\n * @method createAccountKey\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\n * @return {Object}\n */\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n    if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys\n\n    if (_.isString(accountKey)) {\n        accountKey = this.createAccountKeyPublic(accountKey)\n    } else if (_.isArray(accountKey)) {\n        accountKey = this.createAccountKeyMultiSig(accountKey)\n    } else if (_.isObject(accountKey)) {\n        accountKey = this.createAccountKeyRoleBased(accountKey)\n    } else {\n        throw new Error(`Invalid accountKey type: ${typeof accountKey}`)\n    }\n    return accountKey\n}\n\n/**\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\n *\n * @method createAccountKeyPublic\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n    if (privateKey instanceof AccountKeyPublic) return privateKey\n\n    if (!_.isString(privateKey)) {\n        throw new Error('Creating a AccountKeyPublic requires a private key string.')\n    }\n\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n\n    if (!utils.isValidPrivateKey(privateKey)) {\n        throw new Error(`Failed to create AccountKeyPublic. Invalid private key : ${privateKey}`)\n    }\n\n    return new AccountKeyPublic(privateKey)\n}\n\n/**\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\n *\n * @method createAccountKeyMultiSig\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n    if (privateKeys instanceof AccountKeyMultiSig) return privateKeys\n\n    if (!_.isArray(privateKeys)) {\n        throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.')\n    }\n\n    for (let i = 0; i < privateKeys.length; i++) {\n        const parsed = utils.parsePrivateKey(privateKeys[i])\n        const p = parsed.privateKey\n        if (!utils.isValidPrivateKey(p)) {\n            throw new Error(`Failed to create AccountKeyMultiSig. Invalid private key : ${p}`)\n        }\n    }\n\n    return new AccountKeyMultiSig(privateKeys)\n}\n\n/**\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\n *\n * @method createAccountKeyRoleBased\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n    if (keyObject instanceof AccountKeyRoleBased) return keyObject\n\n    if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n        throw new Error('Creating a AccountKeyRoleBased requires an object.')\n    }\n\n    return new AccountKeyRoleBased(keyObject)\n}\n\n/**\n * accountKeyToPublicKey creates public key format with AccountKey.\n *\n * @method accountKeyToPublicKey\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\n * @return {String|Array|Object}\n */\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n    accountKey = this.createAccountKey(accountKey)\n    return accountKey.toPublicKey(this.privateKeyToPublicKey)\n}\n\n/**\n * createWithAccountKey creates Account instance with AccountKey.\n *\n * @method createWithAccountKey\n * @param {String} address The address of account.\n * @param {String|Array|Object} accountKey The accountKey of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n    const account = new Account(address, this.createAccountKey(accountKey))\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\n *\n * @method createWithAccountKeyPublic\n * @param {String} address An address of account.\n * @param {String|Object} key Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n    if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key)\n\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error(`Failed to create account with AccountKeyPublic. Invalid account key : ${key.type}`)\n    }\n\n    const account = new Account(address, key)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\n *\n * @method createWithAccountKeyMultiSig\n * @param {String} address An address of account.\n * @param {String|Object} keys Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n    if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys)\n\n    if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n        throw new Error(`Failed to create account with AccountKeyMultiSig. Invalid account key : ${keys.type}`)\n    }\n\n    const account = new Account(address, keys)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\n *\n * @method createWithAccountKeyRoleBased\n * @param {String} address An address of account.\n * @param {String|Object} keyObject Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n    if (!Account.isAccountKey(keyObject)) {\n        keyObject = this.createAccountKeyRoleBased(keyObject)\n    }\n\n    if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n        throw new Error(`Failed to create account with AccountKeyRoleBased. Invalid account key : ${keyObject.type}`)\n    }\n\n    const account = new Account(address, keyObject)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\n *\n * @method privateKeyToAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\n * @return {Object}\n */\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n    const { legacyAccount: account, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\n\n    account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress)\n    account.address = account.address.toLowerCase()\n    account.address = utils.addHexPrefix(account.address)\n\n    return account\n}\n\n/**\n * createAccountForUpdate creates an AccountForUpdate instance.\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\n *\n * @method createAccountForUpdate\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n    let legacyOrFail\n\n    // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n    if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n        legacyOrFail = {}\n        Object.keys(accountKey).map(role => {\n            if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n                legacyOrFail[role] = accountKey[role]\n                delete accountKey[role]\n            }\n        })\n        if (Object.keys(accountKey).length === 0) {\n            return new AccountForUpdate(address, legacyOrFail, options)\n        }\n    }\n\n    const publicKey = this.accountKeyToPublicKey(accountKey)\n\n    if (legacyOrFail !== undefined) {\n        Object.assign(publicKey, legacyOrFail)\n    }\n\n    return new AccountForUpdate(address, publicKey, options)\n}\n\n/**\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\n *\n * @method createAccountForUpdateWithPublicKey\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} keyForUpdate Public key to update.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n    return new AccountForUpdate(address, keyForUpdate, options)\n}\n\n/**\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\n *\n * @method createAccountForUpdateWithLegacyKey\n * @param {String} address The address of account to update with the legacy key.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n    return new AccountForUpdate(address, 'legacyKey')\n}\n\n/**\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\n *\n * @method createAccountForUpdateWithFailKey\n * @param {String} address The address of account to update with the fail key.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n    return new AccountForUpdate(address, 'failKey')\n}\n\n/**\n * isDecoupled determines whether or not it is decoupled based on the input value.\n *\n * @method isDecoupled\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\n * @return {Boolean}\n */\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n    const { legacyAccount, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\n    const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress)\n\n    return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase()\n}\n\n/**\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\n *\n * @method getLegacyAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @return {Object}\n */\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n    const parsed = utils.parsePrivateKey(key)\n\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    const privateKey = utils.addHexPrefix(parsed.privateKey)\n\n    const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)))\n\n    return { legacyAccount: account, klaytnWalletKeyAddress: parsed.address }\n}\n\n/**\n * signTransaction signs to transaction with private key.\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\n *\n * @method signTransaction\n * @param {String|Object} tx The transaction to sign.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.signTransaction = function signTransaction() {\n    const _this = this\n    let isLegacy = false\n    let isFeePayer = false\n    let existedSenderSignatures = []\n    let existedFeePayerSignatures = []\n    let result\n    let tx\n    let privateKey\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForSignTransaction(arguments)\n        tx = resolved.tx\n        privateKey = resolved.privateKey\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    // If the user signs an RLP encoded transaction, tx is of type string.\n    if (_.isString(tx)) {\n        tx = decodeFromRawTransaction(tx)\n    }\n\n    // Validate tx object\n    const error = helpers.validateFunction.validateParams(tx)\n    if (error) return handleError(error)\n\n    if (tx.senderRawTransaction) {\n        if (tx.feePayerSignatures) {\n            existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures)\n        }\n\n        try {\n            // Decode senderRawTransaction to get signatures of fee payer\n            const { senderRawTransaction, feePayer, feePayerSignatures } = splitFeePayer(tx.senderRawTransaction)\n\n            // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n            if (feePayer !== '0x') {\n                // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n                if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n                    return handleError(\n                        `Invalid feePayer: The fee payer(${feePayer}) included in the transaction does not match the fee payer(${tx.feePayer}) you want to sign.`\n                    )\n                }\n                existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures)\n            }\n\n            tx.senderRawTransaction = senderRawTransaction\n            isFeePayer = true\n        } catch (e) {\n            return handleError(e)\n        }\n    } else {\n        isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY')\n\n        if (tx.signatures) {\n            // if there is existed signatures or feePayerSignatures, those should be preserved.\n            if (isLegacy) {\n                return handleError('Legacy transaction cannot be signed with multiple keys.')\n            }\n            existedSenderSignatures = existedSenderSignatures.concat(tx.signatures)\n        }\n    }\n\n    // When privateKey is undefined, find Account from Wallet.\n    if (privateKey === undefined) {\n        try {\n            const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from)\n            if (!account) {\n                return handleError(\n                    'Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.'\n                )\n            }\n            privateKey = this._getRoleKey(tx, account)\n        } catch (e) {\n            return handleError(e)\n        }\n    }\n\n    const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey]\n\n    try {\n        for (let i = 0; i < privateKeys.length; i++) {\n            const parsed = utils.parsePrivateKey(privateKeys[i])\n            privateKeys[i] = parsed.privateKey\n            privateKeys[i] = utils.addHexPrefix(privateKeys[i])\n\n            if (!utils.isValidPrivateKey(privateKeys[i])) {\n                return handleError('Invalid private key')\n            }\n        }\n    } catch (e) {\n        return handleError(e)\n    }\n\n    // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n    if (isLegacy) {\n        if (privateKeys.length > 1) {\n            return handleError('Legacy transaction cannot signed with multiple keys')\n        }\n        if (_this.isDecoupled(privateKeys[0], tx.from)) {\n            return handleError('A legacy transaction must be with a legacy account key')\n        }\n    }\n\n    function signed(txObject) {\n        try {\n            // Guarantee all property in transaction is hex.\n            txObject = helpers.formatters.inputCallFormatter(txObject)\n\n            const transaction = coverInitialTxValue(txObject)\n\n            const rlpEncoded = encodeRLPByTxType(transaction)\n\n            const messageHash = Hash.keccak256(rlpEncoded)\n\n            const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures\n\n            for (const p of privateKeys) {\n                const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p)\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n                sigs.push([v, r, s])\n            }\n            // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\n\n            result = {\n                messageHash,\n                v: sigs[0][0],\n                r: sigs[0][1],\n                s: sigs[0][2],\n                rawTransaction,\n                txHash: Hash.keccak256(rawTransaction),\n                senderTxHash: getSenderTxHash(rawTransaction),\n            }\n\n            if (isFeePayer) {\n                result.feePayerSignatures = feePayerSignatures\n            } else {\n                result.signatures = signatures\n            }\n        } catch (e) {\n            callback(e)\n            return Promise.reject(e)\n        }\n\n        callback(null, result)\n        return result\n    }\n\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n        return Promise.resolve(signed(tx))\n    }\n\n    // When the feePayer signs a transaction, required information is only chainId.\n    if (isFeePayer) {\n        return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function(args) {\n            if (isNot(args[0])) {\n                throw new Error(`\"chainId\" couldn't be fetched: ${JSON.stringify(args)}`)\n            }\n            return signed(_.extend(tx, { chainId: args[0] }))\n        })\n    }\n\n    // Otherwise, get the missing info from the Klaytn Node\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        return signed(\n            _.extend(tx, {\n                chainId: args[0],\n                gasPrice: args[1],\n                nonce: args[2],\n            })\n        )\n    })\n}\n\n/**\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\n *\n * @method feePayerSignTransaction\n * @param {Object|String} tx The transaction to sign.\n * @param {String} feePayer The address of fee payer.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n    const _this = this\n    let tx\n    let feePayer\n    let privateKey\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForFeePayerSignTransaction(arguments)\n        tx = resolved.tx\n        feePayer = resolved.feePayer\n        privateKey = resolved.privateKey\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    if (_.isString(tx)) {\n        return this.signTransaction({ senderRawTransaction: tx, feePayer }, privateKey, callback)\n    }\n\n    if (!tx.feePayer || tx.feePayer === '0x') {\n        tx.feePayer = feePayer\n    }\n\n    if (!tx.senderRawTransaction) {\n        if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n            return handleError(`Failed to sign transaction with fee payer: invalid transaction type(${tx.type ? tx.type : 'LEGACY'})`)\n        }\n    }\n\n    const e = helpers.validateFunction.validateParams(tx)\n    if (e) {\n        return handleError(e)\n    }\n\n    if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n        return handleError('Invalid parameter: The address of fee payer does not match.')\n    }\n\n    if (tx.senderRawTransaction) {\n        return this.signTransaction(tx, privateKey, callback)\n    }\n\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        const chainId = args[0]\n        const gasPrice = args[1]\n        const nonce = args[2]\n\n        if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        let transaction = _.extend(tx, { chainId, gasPrice, nonce })\n\n        transaction = helpers.formatters.inputCallFormatter(transaction)\n        transaction = coverInitialTxValue(transaction)\n\n        const rlpEncoded = encodeRLPByTxType(transaction)\n        const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']]\n        const { rawTransaction } = makeRawTransaction(rlpEncoded, sig, transaction)\n\n        return _this.signTransaction({ senderRawTransaction: rawTransaction, feePayer, chainId }, privateKey, callback)\n    })\n}\n\n/**\n * signTransactionWithHash signs to transaction hash with private key(s).\n *\n * @method signTransactionWithHash\n * @param {String} hash The hash of transaction to sign.\n * @param {String|Array} privateKeys The private key(s) to use for signing.\n * @param {String|Number} chainId The chain id of the network.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n    const _this = this\n    let hash\n    let privateKeys\n    let chainId\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForSignTransactionWithHash(arguments)\n        hash = resolved.hash\n        chainId = resolved.chainId\n        privateKeys = resolved.privateKeys\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys]\n\n    function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n        const result = []\n        chain = utils.numberToHex(chain)\n\n        try {\n            for (const privateKey of prvKeys) {\n                const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey)\n                if (!utils.isValidPrivateKey(p)) {\n                    return handleError(`Failed to sign transaction with hash: Invalid private key ${privateKey}`)\n                }\n\n                const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p)\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n\n                result.push(utils.transformSignaturesToObject([v, r, s]))\n            }\n        } catch (e) {\n            callbackFunc(e)\n            return Promise.reject(e)\n        }\n\n        callbackFunc(null, result)\n        return result\n    }\n\n    return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n        return signWithHash(hash, privateKeys, id, callback)\n    })\n}\n\n/**\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\n *\n * @method getRawTransactionWithSignatures\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n    const _this = this\n    let result\n\n    callback = callback || function() {}\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    if (!tx || !_.isObject(tx)) {\n        return handleError('Invalid parameter: The transaction must be defined as an object')\n    }\n    if (!tx.signatures && !tx.feePayerSignatures) {\n        return handleError('There are no signatures or feePayerSignatures defined in the transaction object.')\n    }\n\n    const error = helpers.validateFunction.validateParams(tx)\n    if (error) return handleError(error)\n\n    if (tx.senderRawTransaction) {\n        tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']]\n\n        const decoded = decodeFromRawTransaction(tx.senderRawTransaction)\n        // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n        if (decoded.feePayer !== '0x' && !utils.isEmptySig(decoded.feePayerSignatures)) {\n            if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n                return handleError('Invalid feePayer')\n            }\n            tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures)\n        }\n\n        decoded.feePayer = tx.feePayer\n        decoded.feePayerSignatures = tx.feePayerSignatures\n\n        if (tx.signatures) {\n            decoded.signatures = decoded.signatures.concat(tx.signatures)\n        }\n        tx = decoded\n    }\n\n    function signed(txObject) {\n        try {\n            // Guarantee all property in transaction is hex.\n            txObject = helpers.formatters.inputCallFormatter(txObject)\n\n            const transaction = coverInitialTxValue(txObject)\n\n            const rlpEncoded = encodeRLPByTxType(transaction)\n\n            let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x']\n\n            if (!_.isArray(sigs[0])) sigs = [sigs]\n\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\n\n            result = {\n                rawTransaction,\n                txHash: Hash.keccak256(rawTransaction),\n                senderTxHash: getSenderTxHash(rawTransaction),\n            }\n\n            if (signatures && !utils.isEmptySig(signatures)) {\n                result.signatures = signatures\n            }\n\n            if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n                result.feePayerSignatures = feePayerSignatures\n            }\n        } catch (e) {\n            callback(e)\n            return Promise.reject(e)\n        }\n\n        callback(null, result)\n        return result\n    }\n\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n        return Promise.resolve(signed(tx))\n    }\n\n    // Otherwise, get the missing info from the Klaytn Node\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        return signed(\n            _.extend(tx, {\n                chainId: args[0],\n                gasPrice: args[1],\n                nonce: args[2],\n            })\n        )\n    })\n}\n\n/**\n * combineSignatures combines RLP encoded raw transaction strings.\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\n * The comparison allows that the address of the fee payer is '0x'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\n * In this case, feePayer field doesn't have to be compared with other transaction.\n *\n * @method combineSignatures\n * @param {Array} rawTransactions The array of raw transaction string to combine.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n    let decodedTx\n    let senders = []\n    let feePayers = []\n    let feePayer\n\n    callback = callback || function() {}\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    if (!_.isArray(rawTransactions)) {\n        return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.')\n    }\n\n    for (const raw of rawTransactions) {\n        const { senderSignatures, feePayerSignatures, decodedTransaction } = extractSignatures(raw)\n\n        senders = senders.concat(senderSignatures)\n        feePayers = feePayers.concat(feePayerSignatures)\n\n        if (decodedTx) {\n            let isSame = true\n            const keys = Object.keys(decodedTx)\n            for (const key of keys) {\n                if (\n                    key === 'v' ||\n                    key === 'r' ||\n                    key === 's' ||\n                    key === 'signatures' ||\n                    key === 'payerV' ||\n                    key === 'payerR' ||\n                    key === 'payerS' ||\n                    key === 'feePayerSignatures'\n                ) {\n                    continue\n                }\n\n                // feePayer field can be '0x' when after sender signs to trasnaction.\n                // For handling this, if feePayer is '0x', don't compare with other transaction\n                if (key === 'feePayer') {\n                    if (decodedTransaction[key] === '0x') {\n                        continue\n                    } else {\n                        // set feePayer letiable with valid feePayer address(not '0x')\n                        feePayer = decodedTransaction[key]\n                        if (decodedTx[key] === '0x') {\n                            // set feePayer field to decodedTx for comparing feePayer address with other transactions\n                            decodedTx[key] = decodedTransaction[key]\n                        }\n                    }\n                }\n\n                if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n                    isSame = false\n                    break\n                }\n            }\n            if (!isSame) {\n                return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.')\n            }\n        } else {\n            decodedTx = decodedTransaction\n        }\n    }\n\n    const parsedTxObject = decodeFromRawTransaction(rawTransactions[0])\n    parsedTxObject.signatures = senders\n\n    if (feePayer) {\n        parsedTxObject.feePayer = feePayer\n        if (feePayers.length > 0) {\n            parsedTxObject.feePayerSignatures = feePayers\n        }\n    }\n    return this.getRawTransactionWithSignatures(parsedTxObject, callback)\n}\n\n/**\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n    if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n        throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".')\n    }\n\n    const values = RLP.decode(rawTx)\n\n    // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n    const arr = values.slice(7, 9).map(sig => {\n        sig = sig.replace('0x', '')\n        while (sig.length < 64) {\n            sig = `0${sig}`\n        }\n        return `0x${sig}`\n    })\n    arr.unshift(values[6])\n\n    const signature = AccountLib.encodeSignature(arr)\n    const recovery = Bytes.toNumber(values[6])\n    const extraData = recovery < 35 ? [] : [Bytes.fromNumber((recovery - 35) >> 1), '0x', '0x']\n    const signingData = values.slice(0, 6).concat(extraData)\n    const signingDataHex = RLP.encode(signingData)\n\n    return AccountLib.recover(Hash.keccak256(signingDataHex), signature)\n}\n\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\nAccounts.prototype.hashMessage = function hashMessage(data) {\n    const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data\n    const messageBuffer = Buffer.from(message)\n    const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`\n    const preambleBuffer = Buffer.from(preamble)\n    // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n    const klayMessage = Buffer.concat([preambleBuffer, messageBuffer])\n    // Finally, run keccak256 on klayMessage.\n    return Hash.keccak256(klayMessage)\n}\n\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\nAccounts.prototype.sign = function sign(data, privateKey) {\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n    if (!utils.isValidPrivateKey(privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    const messageHash = this.hashMessage(data)\n    const signature = AccountLib.sign(messageHash, privateKey)\n    const [v, r, s] = AccountLib.decodeSignature(signature)\n    return {\n        message: data,\n        messageHash,\n        v,\n        r,\n        s,\n        signature,\n    }\n}\n\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n    const args = [].slice.apply(arguments)\n\n    if (_.isObject(message)) {\n        return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true)\n    }\n\n    if (!preFixed) {\n        message = this.hashMessage(message)\n    }\n\n    if (args.length >= 4) {\n        preFixed = args.slice(-1)[0]\n        preFixed = _.isBoolean(preFixed) ? !!preFixed : false\n\n        return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed) // v, r, s\n    }\n    /**\n     * recover in Account module\n     * const recover = (hash, signature) => {\n     *   const vals = decodeSignature(signature);\n     *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n     *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n     *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\n     *   const publicHash = keccak256(publicKey);\n     *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n     *   return address;\n     * };\n     */\n    return AccountLib.recover(message, signature)\n}\n\n// Taken from https://github.com/ethereumjs/ethereumjs-wallet\nAccounts.prototype.decrypt = function(v3Keystore, password, nonStrict) {\n    if (!_.isString(password)) {\n        throw new Error('No password given.')\n    }\n\n    const json = _.isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore)\n\n    if (json.version !== 3 && json.version !== 4) {\n        console.warn('This is not a V3 or V4 wallet.')\n        // throw new Error('Not a valid V3 wallet');\n    }\n\n    if (json.version === 3 && !json.crypto) {\n        // crypto field should be existed in keystore version 3\n        throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\")\n    }\n\n    if (json.crypto) {\n        if (json.keyring) {\n            throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\")\n        }\n        json.keyring = [json.crypto]\n        delete json.crypto\n    }\n\n    if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n        throw new Error('Invalid key store format')\n    }\n\n    let accountKey = {}\n\n    // AccountKeyRoleBased format\n    if (_.isArray(json.keyring[0])) {\n        const transactionKey = decryptKey(json.keyring[0])\n        if (transactionKey) accountKey.transactionKey = transactionKey\n\n        const updateKey = decryptKey(json.keyring[1])\n        if (updateKey) accountKey.updateKey = updateKey\n\n        const feePayerKey = decryptKey(json.keyring[2])\n        if (feePayerKey) accountKey.feePayerKey = feePayerKey\n    } else {\n        accountKey = decryptKey(json.keyring)\n    }\n\n    function decryptKey(encryptedArray) {\n        if (!encryptedArray || encryptedArray.length === 0) return undefined\n\n        const decryptedArray = []\n        for (const encrypted of encryptedArray) {\n            let derivedKey\n            let kdfparams\n            /**\n             * Supported kdf modules are the following:\n             * 1) pbkdf2\n             * 2) scrypt\n             */\n            if (encrypted.kdf === 'scrypt') {\n                kdfparams = encrypted.kdfparams\n\n                // FIXME: support progress reporting callback\n                derivedKey = scrypt(\n                    Buffer.from(password),\n                    Buffer.from(kdfparams.salt, 'hex'),\n                    kdfparams.n,\n                    kdfparams.r,\n                    kdfparams.p,\n                    kdfparams.dklen\n                )\n            } else if (encrypted.kdf === 'pbkdf2') {\n                kdfparams = encrypted.kdfparams\n\n                if (kdfparams.prf !== 'hmac-sha256') {\n                    throw new Error('Unsupported parameters to PBKDF2')\n                }\n\n                derivedKey = cryp.pbkdf2Sync(\n                    Buffer.from(password),\n                    Buffer.from(kdfparams.salt, 'hex'),\n                    kdfparams.c,\n                    kdfparams.dklen,\n                    'sha256'\n                )\n            } else {\n                throw new Error('Unsupported key derivation scheme')\n            }\n\n            const ciphertext = Buffer.from(encrypted.ciphertext, 'hex')\n\n            const mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '')\n            if (mac !== encrypted.mac) {\n                throw new Error('Key derivation failed - possibly wrong password')\n            }\n\n            const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'))\n            decryptedArray.push(`0x${Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex')}`)\n        }\n        return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray\n    }\n\n    return this.createWithAccountKey(json.address, accountKey)\n}\n\n/*\n    The fields of kdfparams are described below.\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n */\n/**\n * encrypt encrypts an account and returns a key store v4 object.\n *\n * @method encrypt\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\nAccounts.prototype.encrypt = function(key, password, options) {\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    options = options || {}\n\n    let address\n    let account\n\n    if (key instanceof Account) {\n        if (options.address && options.address !== key.address) {\n            throw new Error('Address in account is not matched with address in options object')\n        }\n        address = key.address\n        account = key\n    } else if (_.isString(key)) {\n        account = this.privateKeyToAccount(key, options.address)\n        address = account.address\n    } else {\n        if (!options.address) {\n            throw new Error('The address must be defined inside the options object.')\n        }\n        address = options.address\n    }\n\n    if (!account) account = this.createWithAccountKey(address, key)\n\n    let keyring\n    let transactionKey\n    let updateKey\n    let feePayerKey\n\n    switch (account.accountKeyType) {\n        case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n        case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n            keyring = encryptKey(account.keys, password, options)\n            break\n        case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n            keyring = []\n            transactionKey = encryptKey(account.transactionKey, password, options)\n            updateKey = encryptKey(account.updateKey, password, options)\n            feePayerKey = encryptKey(account.feePayerKey, password, options)\n            keyring.push(transactionKey)\n            keyring.push(updateKey)\n            keyring.push(feePayerKey)\n            for (let i = keyring.length - 1; i >= 0; i--) {\n                if (keyring[i].length !== 0) break\n                keyring = keyring.slice(0, i)\n            }\n            break\n        default:\n            throw new Error(`Unsupported account key type: ${account.accountKeyType}`)\n    }\n\n    return {\n        version: 4,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase(),\n        keyring,\n    }\n}\n\n/**\n * encryptV3 encrypts an account and returns a key store v3 object.\n *\n * @method encryptV3\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\nAccounts.prototype.encryptV3 = function(key, password, options) {\n    options = options || {}\n\n    let address\n    let account\n    const notSupportedType =\n        'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.'\n\n    if (key instanceof Account) {\n        if (options.address && options.address !== key.address) {\n            throw new Error('Address in account is not matched with address in options object')\n        }\n        if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\n\n        address = key.address\n        account = key\n    } else if (_.isString(key)) {\n        account = this.privateKeyToAccount(key, options.address)\n        address = account.address\n    } else if (Account.isAccountKey(key)) {\n        if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\n        if (!options.address) {\n            throw new Error('The address must be defined inside the options object.')\n        }\n\n        address = options.address\n    } else {\n        throw new Error(notSupportedType)\n    }\n\n    if (!account) account = this.createWithAccountKey(address, key)\n\n    const crypto = encryptKey(account.keys, password, options)\n\n    return {\n        version: 3,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase(),\n        crypto: crypto[0],\n    }\n}\n\nAccounts.prototype.privateKeyToPublicKey = function(privateKey, compressed = false) {\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey\n\n    if (privateKey.length !== 64) {\n        throw new Error('Received a invalid privateKey. The length of privateKey should be 64.')\n    }\n    const buffer = Buffer.from(privateKey, 'hex')\n    const ecKey = secp256k1.keyFromPrivate(buffer)\n\n    let publicKey\n\n    if (!compressed) {\n        publicKey = `0x${ecKey.getPublic(false, 'hex').slice(2)}`\n    } else {\n        publicKey = `0x${ecKey.getPublic(true, 'hex')}`\n    }\n\n    return publicKey\n}\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType\n\nAccounts.prototype.setAccounts = function(accounts) {\n    this.wallet.clear()\n\n    for (let i = 0; i < accounts.wallet.length; i++) {\n        this.wallet.add(accounts.wallet[i])\n    }\n\n    return this\n}\n\n/* eslint-enable complexity */\n\n// Note: this is trying to follow closely the specs on\n\n/**\n  > Wallet {\n      0: {...}, // account by index\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n      1: {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n      add: function(){},\n      remove: function(){},\n      save: function(){},\n      load: function(){},\n      clear: function(){},\n\n      length: 2,\n  }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n */\nfunction Wallet(accounts) {\n    this._accounts = accounts\n    this.length = 0\n    this.defaultKeyName = 'caverjs_wallet'\n}\n\nWallet.prototype._findSafeIndex = function(pointer) {\n    pointer = pointer || 0\n    if (_.has(this, pointer)) {\n        return this._findSafeIndex(pointer + 1)\n    }\n    return pointer\n}\n\nWallet.prototype._currentIndexes = function() {\n    const keys = Object.keys(this)\n    const indexes = keys\n        .map(function(key) {\n            return parseInt(key)\n        })\n        .filter(function(n) {\n            return n < 9e20\n        })\n\n    return indexes\n}\n\nWallet.prototype.create = function(numberOfAccounts, entropy) {\n    for (let i = 0; i < numberOfAccounts; ++i) {\n        this.add(this._accounts.create(entropy).privateKey)\n    }\n    return this\n}\n\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n */\nWallet.prototype.add = function(account, userInputAddress) {\n    let accountForWallet\n    /**\n     * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n     *\n     * cav.klay.accounts.wallet.add({\n     *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n     *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n     * });\n     */\n    if (Account.isAccountKey(account)) {\n        if (!userInputAddress) {\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey')\n        }\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account)\n    } else if (account instanceof Account) {\n        accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey)\n        accountForWallet.address = userInputAddress || account.address\n    } else if (_.isObject(account) && account.address && account.privateKey) {\n        accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address)\n    } else if (_.isString(account)) {\n        accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress)\n    } else {\n        const accountKey = this._accounts.createAccountKey(account)\n        if (!userInputAddress) {\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey format')\n        }\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey)\n    }\n\n    if (this[accountForWallet.address]) {\n        throw new Error(`Account exists with ${accountForWallet.address}`)\n    }\n\n    accountForWallet.index = this._findSafeIndex()\n    this[accountForWallet.index] = accountForWallet\n\n    this[accountForWallet.address] = accountForWallet\n    this[accountForWallet.address.toLowerCase()] = accountForWallet\n    this[accountForWallet.address.toUpperCase()] = accountForWallet\n    try {\n        this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet\n    } catch (e) {}\n\n    this.length++\n\n    return accountForWallet\n}\n\nWallet.prototype.updatePrivateKey = function(privateKey, address) {\n    if (privateKey === undefined || address === undefined) {\n        throw new Error('To update the privatKey in wallet, need to set both privateKey and address.')\n    }\n\n    // If privateKey parameter is not string type, return error\n    if (!_.isString(privateKey)) {\n        throw new Error('The private key used for the update is not a valid string.')\n    }\n\n    if (!utils.isAddress(address)) {\n        throw new Error(`Invalid address : ${address}`)\n    }\n\n    // If failed to find account through address, return error\n    const accountExists = !!this[address]\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\n\n    const account = this[address]\n\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error(\n            'Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.'\n        )\n    }\n\n    const parsed = utils.parsePrivateKey(privateKey)\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    if (parsed.address && parsed.address !== account.address) {\n        throw new Error('The address extracted from the private key does not match the address received as the input value.')\n    }\n\n    const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey)\n    this[account.index].accountKey = newAccountKeyPublic\n    this[account.address].accountKey = newAccountKeyPublic\n    this[account.address.toLowerCase()].accountKey = newAccountKeyPublic\n    this[account.address.toUpperCase()].accountKey = newAccountKeyPublic\n\n    try {\n        this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic\n    } catch (e) {}\n\n    return account\n}\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n    if (address === undefined || accountKey === undefined) {\n        throw new Error('To update the accountKey in wallet, need to set both address and accountKey.')\n    }\n\n    if (!Account.isAccountKey(accountKey)) {\n        accountKey = this._accounts.createAccountKey(accountKey)\n    }\n\n    if (!utils.isAddress(address)) {\n        throw new Error(`Invalid address : ${address}`)\n    }\n\n    // If failed to find account through address, return error\n    const accountExists = !!this[address]\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\n\n    const account = this[address]\n\n    this[account.index].accountKey = accountKey\n    this[account.address].accountKey = accountKey\n    this[account.address.toLowerCase()].accountKey = accountKey\n    this[account.address.toUpperCase()].accountKey = accountKey\n\n    try {\n        this[utils.toChecksumAddress(account.address)].accountKey = accountKey\n    } catch (e) {}\n\n    return account\n}\n\nWallet.prototype.remove = function(addressOrIndex) {\n    const account = this[addressOrIndex]\n\n    if (account && account.address) {\n        // address\n        this[account.address].accountKey = null\n        delete this[account.address]\n\n        if (this[account.address.toLowerCase()]) {\n            // address lowercase\n            this[account.address.toLowerCase()].accountKey = null\n            delete this[account.address.toLowerCase()]\n        }\n\n        if (this[account.address.toUpperCase()]) {\n            // address uppercase\n            this[account.address.toUpperCase()].accountKey = null\n            delete this[account.address.toUpperCase()]\n        }\n\n        try {\n            this[utils.toChecksumAddress(account.address)].accountKey = null\n            delete this[utils.toChecksumAddress(account.address)]\n        } catch (e) {}\n\n        // index\n        this[account.index].accountKey = null\n        delete this[account.index]\n\n        this.length--\n\n        return true\n    }\n    return false\n}\n\nWallet.prototype.clear = function() {\n    const _this = this\n    const indexes = this._currentIndexes()\n\n    indexes.forEach(function(index) {\n        _this.remove(index)\n    })\n\n    return this\n}\n\n/**\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\nWallet.prototype.encrypt = function(password, options) {\n    const _this = this\n    const indexes = this._currentIndexes()\n\n    const accounts = indexes.map(function(index) {\n        return _this[index].encrypt(password, options)\n    })\n\n    return accounts\n}\n\n/**\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\nWallet.prototype.decrypt = function(encryptedWallet, password) {\n    const _this = this\n\n    encryptedWallet.forEach(function(keystore) {\n        const account = _this._accounts.decrypt(keystore, password)\n\n        if (!account) {\n            throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\")\n        }\n\n        const exist = !!_this[account.address]\n        if (!exist) {\n            _this.add(account)\n        }\n    })\n\n    return this\n}\n\nWallet.prototype.save = function(password, keyName) {\n    /* eslint-disable-next-line no-undef */\n    localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)))\n\n    return true\n}\n\n/**\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\nWallet.prototype.load = function(password, keyName) {\n    /* eslint-disable-next-line no-undef */\n    let keystore = localStorage.getItem(keyName || this.defaultKeyName)\n\n    if (keystore) {\n        try {\n            keystore = JSON.parse(keystore)\n        } catch (e) {}\n    }\n\n    return this.decrypt(keystore || [], password)\n}\n\nif (typeof localStorage === 'undefined') {\n    delete Wallet.prototype.save\n    delete Wallet.prototype.load\n}\n\nWallet.prototype.getKlaytnWalletKey = function(addressOrIndex) {\n    const account = this[addressOrIndex]\n    if (!account) throw new Error('Failed to find account')\n\n    return genKlaytnWalletKeyStringFromAccount(account)\n}\n\nWallet.prototype.getAccount = function(input) {\n    if (_.isNumber(input)) {\n        if (this.length <= input) {\n            throw new Error(`The index(${input}) is out of range(Wallet length : ${this.length}).`)\n        }\n        return this[input]\n    }\n\n    if (!_.isString(input)) {\n        throw new Error(`Accounts in the Wallet can be searched by only index or address. :${input}`)\n    }\n\n    if (!utils.isAddress(input)) {\n        throw new Error(`Failed to getAccount from Wallet: invalid address(${input})`)\n    }\n\n    return this[input.toLowerCase()]\n}\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.')\n    }\n    let addressString = account.address\n    let { privateKey } = account\n\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : `0x${privateKey}`\n    addressString = addressString.slice(0, 2) === '0x' ? addressString : `0x${addressString}`\n\n    return `${privateKey}0x00${addressString}`\n}\n\nmodule.exports = Accounts\n"]},"metadata":{},"sourceType":"script"}